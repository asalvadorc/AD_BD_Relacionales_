<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://asalvadorc.github.io/AD_BD_Relacionales_/Operaciones/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>üîπOperaciones sobre la BD - AD - Acc√©s a Dades</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../css/extra.css" rel="stylesheet" />
        <link href="../css/copy-button.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\ud83d\udd39Operaciones sobre la BD";
        var mkdocs_page_input_path = "Operaciones.md";
        var mkdocs_page_url = "/AD_BD_Relacionales_/Operaciones/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="..">
          <img src="../assets/logocaminas.png" class="logo" alt="Logo"/>
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Bases de Datos Relacionales</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../RA_CE/">üîπRA y CE</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Introduccion/">üîπIntroducci√≥n</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Conectores/">üîπHerramientas y Conectores</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">üîπOperaciones sobre la BD</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#crud-sqlite">üîπCRUD - SQlite</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#liberacion-de-recursos">üîπLiberaci√≥n de recursos</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#crud-postgresql">üîπCRUD - PostgreSQL</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#servidor-remoto">üóÑÔ∏èServidor remoto</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#docker">üê≥ Docker</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#data-class">üîπData Class</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#uso-de-data-class-en-la-bd-geo">üìå Uso de data class en la BD Geo</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Transacciones/">üîπTransacciones y control de errores</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Procedimientos/">üîπFunciones y Procedimientos almacenados</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Ejercicio/">üìù Ejercicio obligatorio</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">AD - Acc√©s a Dades</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Bases de Datos Relacionales</li>
      <li class="breadcrumb-item active">üîπOperaciones sobre la BD</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="operaciones-sobre-la-bd">Operaciones sobre la BD<a class="headerlink" href="#operaciones-sobre-la-bd" title="Permanent link">&para;</a></h1>
<p>En <strong>JDBC</strong> (Java Database Connectivity), las operaciones sobre la base de datos se realizan  utilizando los siguientes objetos y m√©todos:</p>
<ul>
<li>
<p><strong>Connection</strong>, como ya se explic√≥ en el apartado anterior, establece el canal de comunicaci√≥n con el SGBD (PostgreSQL, MySQL, etc.)</p>
</li>
<li>
<p>Los objetos <strong>PrepareStatement</strong> y <strong>CreateStatement</strong> se utlizan  para enviar consultas SQL desde tu programa hacia la base de datos, pero se usan de forma distinta y tienen ventajas diferentes.</p>
</li>
<li>
<p><strong>ResultSet</strong> es un objeto que contiene el resultado de una consulta SQL, y permite recorrer fila a fila el conjunto de resultados, accediendo a cada campo por nombre o por posici√≥n.</p>
</li>
<li>
<p>Los m√©todos <strong>executeQuery()</strong> y <strong>executeUpdate()</strong> se utilizan para ejecutar sentencias SQL, pero se usan en contextos diferentes, dependiendo de si la consulta devuelve resultados o no.</p>
</li>
</ul>
<p><strong class="azul">Peticiones a la BD</strong></p>
<p>Cuando una aplicaci√≥n se conecta a una base de datos, necesita ejecutar sentencias SQL desde el c√≥digo. En JDBC (Java/Kotlin), existen dos m√©todos principales para ello: <strong>executeQuery()</strong> y <strong>executeUpdate()</strong>.</p>
<p>Ambos permiten enviar instrucciones SQL al gestor de base de datos, pero se usan en situaciones diferentes:</p>
<table>
<thead>
<tr>
<th>M√©todo</th>
<th>Uso principal</th>
<th>Tipo de sentencia SQL</th>
<th>Resultado que devuelve</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>executeQuery()</strong></td>
<td>Realizar consultas</td>
<td>SELECT</td>
<td>Objeto ResultSet con los datos consultados</td>
</tr>
<tr>
<td><strong>executeUpdate()</strong></td>
<td>Realizar modificaciones</td>
<td>INSERT, UPDATE, DELETE, DDL (CREATE, DROP, etc.)</td>
<td>Un entero con el n√∫mero de filas afectadas</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">execute()</p>
<p>El m√©todo <strong>execute()</strong> en JDBC se utiliza principalmente en los siguientes casos:</p>
<ul>
<li>Cuando no se sabe de antemano qu√© tipo de sentencia SQL se va a ejecutar o si la consulta puede ser tanto de consulta como de modificaci√≥n de datos.</li>
<li>Para ejecutar sentencias SQL que pueden devolver varios resultados.</li>
<li>En situaciones donde se necesita una gesti√≥n flexible de la ejecuci√≥n, ya que execute() devuelve un booleano:<ul>
<li>true si el resultado es un ResultSet (SELECT).</li>
<li>false si el resultado es un entero (INSERT, UPDATE, DELETE,CREATE, ALTER)</li>
</ul>
</li>
</ul>
</div>
<p><strong class="azul">PrepareStatement VS CreateStatement</strong></p>
<table>
<thead>
<tr>
<th>Si necesitas...</th>
<th>Usa...</th>
</tr>
</thead>
<tbody>
<tr>
<td>Consultas sin par√°metros</td>
<td><code>CreateStatement</code></td>
</tr>
<tr>
<td>Consultas con datos del usuario</td>
<td><code>PrepareStatement</code></td>
</tr>
<tr>
<td>Seguridad frente a inyecciones SQL</td>
<td><code>PrepareStatement</code></td>
</tr>
<tr>
<td>Ejecutar muchas veces con distintos valores</td>
<td><code>PrepareStatement</code></td>
</tr>
<tr>
<td>Crear tablas o sentencias SQL complejas que no cambian</td>
<td><code>CreateStatement</code></td>
</tr>
</tbody>
</table>
<p><strong>Diferencia en la compilaci√≥n entre Statement y PreparedStatement</strong></p>
<p>Cada vez que env√≠as una sentencia SQL al motor de base de datos, el motor debe hacer varios pasos:</p>
<ul>
<li>Parsear la consulta ‚Üí comprobar que la sintaxis SQL es correcta.</li>
<li>Compilar ‚Üí convertir la consulta en un plan de ejecuci√≥n interno (c√≥mo buscar los datos, qu√© √≠ndices usar, etc.).</li>
<li>Ejecutar ‚Üí obtener los resultados.</li>
</ul>
<p>üîπ <strong>Con Statement</strong></p>
<p>Cada vez que llamas a executeQuery() o executeUpdate(), el SQL completo se env√≠a como texto:</p>
<pre><code>val stmt = conn.createStatement()
stmt.executeQuery("SELECT * FROM clientes WHERE ciudad = 'Valencia'")
stmt.executeQuery("SELECT * FROM clientes WHERE ciudad = 'Madrid'")
</code></pre>
<p>En este caso, el motor parsea y compila de nuevo las dos consultas, aunque solo cambia el valor de 'Valencia' a 'Madrid'.</p>
<p>üîÅ Es decir, se repite todo el trabajo de compilaci√≥n cada vez, lo que reduce el rendimiento si haces muchas consultas parecidas.</p>
<p>üîπ <strong>Con PrepareStatement</strong></p>
<p>Aqu√≠, el SQL se env√≠a una sola vez con par√°metros (?):</p>
<pre><code>val pstmt = conn.prepareStatement("SELECT * FROM clientes WHERE ciudad = ?")
pstmt.setString(1, "Valencia")
pstmt.executeQuery()

pstmt.setString(1, "Madrid")
pstmt.executeQuery()
</code></pre>
<p>El motor solo compila la consulta una vez, y despu√©s reutiliza el mismo plan de ejecuci√≥n cambiando solo el valor del par√°metro.</p>
<p>‚ö° Esto ahorra tiempo y recursos, sobre todo cuando repites muchas veces la misma consulta con diferentes datos (por ejemplo, en bucles o inserciones masivas).    </p>
<h2 id="crud-sqlite">üîπCRUD - SQlite<a class="headerlink" href="#crud-sqlite" title="Permanent link">&para;</a></h2>
<div class="admonition tip">
<p class="admonition-title">Kotlin - Instrucciones</p>
<p>Dentro del paquete <code>SQlite</code> del proyecto  <code>BDRelacionales</code>, ya creado y conectado a la BD <code>Tienda.sqlite</code>, ubicada en la carpeta de <strong>recursos</strong>, incluiremos los ejemplos de este apartado.
Estos ejemplos mostrar√°n c√≥mo gestionar datos desde una aplicaci√≥n en Kotlin conectada a una base de datos relacional ligera, utilizando las tablas <code>article</code>, <code>client</code>, <code>factura</code> y <code>linia_fac</code>, tal y como se aprecia en el modelo relacional de la siguiente imagen.</p>
</div>
<p><strong class="azul">Tienda.sqlite</strong></p>
<table>
<thead>
<tr>
<th>Modelo Relacional</th>
<th>Datos</th>
<th>Paquete SQLite</th>
</tr>
</thead>
<tbody>
<tr>
<td><img alt="ref" src="../img/bd_factura.jpg" /></td>
<td><img alt="ref" src="../img/campos_bd_factura.jpg" /></td>
<td><img alt="ref" src="../img/carpeta_sqlite.png" /></td>
</tr>
</tbody>
</table>
<p><strong class="azul">Operaciones CRUD</strong>   </p>
<p>Las operaciones m√°s habituales para modificar los datos en una base de datos relacional son las conocidas como <strong>CRUD</strong>:</p>
<ul>
<li><strong>CREATE</strong>: Permite a√±adir nuevos registros a una tabla.</li>
<li><strong>READ</strong>: Permite consultar registros existentes.</li>
<li><strong>UPDATE</strong>: Permite modificar los valores de uno o varios registros existentes.</li>
<li><strong>DELETE</strong>: Permite eliminar registros de una tabla.</li>
</ul>
<p><strong class="verde">CREATE (INSERT)</strong> </p>
<p><strong>Ejemplo_Insert.kt</strong>: Este fragmento a√±ade un nuevo articulo "00001" a la tabla articles</p>
<pre><code>package SQLite
import java.sql.DriverManager

fun main() {
    val dbPath = "src/main/resources/Tienda.sqlite"
    val dbFile = java.io.File(dbPath)
    val url = "jdbc:sqlite:${dbFile.absolutePath}"

    DriverManager.getConnection(url).use { conn -&gt;

        val sql = "INSERT INTO article (cod_a, descrip) VALUES (?, ?)"
        //conn.prepareStatement(sql)

        conn.prepareStatement(sql).use { stmt -&gt;

            stmt.setString(1, "00001")
            stmt.setString(2, "articulo de prueba 1")
            stmt.executeUpdate()


        }

        }
    }
</code></pre>
<p><strong class="verde">UPDATE</strong></p>
<p><strong>Ejemplo_Update.kt</strong>: Este c√≥digo actualiza la descripci√≥n del art√≠culo "00001"</p>
<pre><code>    package SQLite
    import java.sql.DriverManager

    fun main() {
        val dbPath = "src/main/resources/Tienda.sqlite"
        val dbFile = java.io.File(dbPath)
        val url = "jdbc:sqlite:${dbFile.absolutePath}"

        DriverManager.getConnection(url).use { conn -&gt;

            val sql = "UPDATE article SET descrip = ? WHERE cod_a = ?"

            conn.prepareStatement(sql).use { stmt -&gt;
                stmt.setString(1, "descripci√≥n nueva")
                stmt.setString(2, "00001")
                stmt.executeUpdate()

            }
        }
    }
</code></pre>
<p><strong class="verde">DELETE</strong></p>
<p><strong>Ejemplo_Delete.kt</strong>: Este fragmento elimina el articulo "00001"</p>
<pre><code>   package SQLite
   import java.sql.DriverManager

    fun main() {
        val dbPath = "src/main/resources/Tienda.sqlite"
        val dbFile = java.io.File(dbPath)
        val url = "jdbc:sqlite:${dbFile.absolutePath}"

        DriverManager.getConnection(url).use { conn -&gt;

            val sql = "DELETE FROM article WHERE cod_a = ?"
            conn.prepareStatement(sql).use { stmt -&gt;
            stmt.setString(1, "00001")
            stmt.executeUpdate()
            }
        }
    }
</code></pre>
<p><strong class="verde">READ (SELECT)</strong></p>
<p><strong>Ejemplo_select_basico.kt</strong>: Consulta la tabla article.</p>
<pre><code>    package SQLite
    import java.io.File
    import java.sql.DriverManager

    fun main() {

        val dbPath = "src/main/resources/Tienda.sqlite"
        val dbFile = File(dbPath)
        println("Ruta de la BD: ${dbFile.absolutePath}")

        val url = "jdbc:sqlite:${dbFile.absolutePath}"

        DriverManager.getConnection(url).use { conn -&gt;

            val sql = "SELECT cod_a, descrip, preu, stock, stock_min FROM article"

            conn.prepareStatement(sql).use { stmt -&gt;

                stmt.executeQuery().use { rs -&gt;

                    println("Art√≠culos disponibles:")
                    println("C√≥digo\tDescripci√≥n\tPrecio\tStock\tStock M√≠nimo")

                    while (rs.next()) {
                        val codA = rs.getString("cod_a")
                        val descrip = rs.getString("descrip")
                        val preu = rs.getDouble("preu")
                        val stock = rs.getInt("stock")
                        val stockMin = rs.getInt("stock_min")

                        println("$codA\t$descrip\t$preu\t$stock\t$stockMin")
                    }

                }
            }
        }
    }
</code></pre>
<p><strong>Ejemplo_join.kt</strong>: Este ejemplo obtiene las l√≠neas de factura con nombre del art√≠culo y ordenado por numero de factura y l√≠nea.</p>
<pre><code>    package SQLite
    import java.sql.DriverManager

    fun main() {
        val dbPath = "src/main/resources/Tienda.sqlite"
        val dbFile = java.io.File(dbPath)
        val url = "jdbc:sqlite:${dbFile.absolutePath}"

        DriverManager.getConnection(url).use { conn -&gt;

            val sql = """
                SELECT lf.num_f, lf.num_l, lf.cod_a, a.descrip, lf.quant, lf.preu
                FROM linia_fac lf
                JOIN article a ON lf.cod_a = a.cod_a
                ORDER BY lf.num_f, lf.num_l
            """.trimIndent()

            conn.prepareStatement(sql).use { stmt -&gt;
                stmt.executeQuery().use { rs -&gt;
                    println("L√≠neas de factura:")
                    println("Factura | L√≠nea | Art√≠culo | Descripci√≥n | Cantidad | Precio")

                    while (rs.next()) {
                        val numF = rs.getInt("num_f")
                        val numL = rs.getInt("num_l")
                        val codA = rs.getString("cod_a")
                        val descrip = rs.getString("descrip")
                        val quant = rs.getInt("quant")
                        val preu = rs.getDouble("preu")

                        println("$numF\t$numL\t$codA\t$descrip\t$quant\t$preu")
                    }
                }
            }
        }
    }
</code></pre>
<h2 id="liberacion-de-recursos">üîπLiberaci√≥n de recursos<a class="headerlink" href="#liberacion-de-recursos" title="Permanent link">&para;</a></h2>
<p>Cuando una aplicaci√≥n accede a una base de datos, abre varios recursos internos que consumen memoria y conexiones activas en el sistema:</p>
<ul>
<li>La conexi√≥n con el servidor de base de datos (Connection)</li>
<li>Las sentencias SQL preparadas (Statement o PreparedStatement)</li>
<li>El resultado de la consulta (ResultSet)</li>
</ul>
<p>Estos recursos no se liberan autom√°ticamente cuando se termina su uso (especialmente en Java o Kotlin con JDBC). Si no se cierran correctamente, se pueden producir problemas como:</p>
<ul>
<li>Fugas de memoria</li>
<li>Bloqueo de conexiones (demasiadas conexiones abiertas)</li>
<li>Degradaci√≥n del rendimiento</li>
<li>Errores inesperados en la aplicaci√≥n</li>
</ul>
<p>üí° En Kotlin, puedes usar <strong>use {}</strong> para cerrar recursos autom√°ticamente al finalizar el bloque, tal y como hemos hecho en los ejemplos anteriores.</p>
<p>Si no utilizas <strong>use {}</strong> en Kotlin (o try-with-resources en Java), entonces debes cerrar manualmente cada uno de los recursos abiertos (ResultSet, Statement y Connection) usando .<strong>close()</strong>, y normalmente deber√≠as hacerlo dentro de un bloque <strong>finally</strong> para garantizar su cierre incluso si ocurre un error. El orden correcto de cierre es del m√°s interno al m√°s externo.</p>
<p>üëâ Los siguientes <strong>ejemplos</strong> muestran como cerrar recursos abiertos sin <strong>use()</strong>, de forma manual y con el bloque <strong>try-catch-finally</strong></p>
<p><strong>Ejemplo_cierre_manual.kt:</strong> Cierra los recurso de forma manual con close()</p>
<pre><code>    package SQLite
    import java.sql.DriverManager
    import java.sql.Connection
    import java.sql.PreparedStatement
    import java.sql.ResultSet

    fun main() {
        val dbPath = "src/main/resources/Tienda.sqlite"
        val dbFile = java.io.File(dbPath)
        val url = "jdbc:sqlite:${dbFile.absolutePath}"

        val conn: Connection = DriverManager.getConnection(url)
        val sql = "SELECT cod_a, descrip, preu, stock, stock_min FROM article"
        val stmt: PreparedStatement = conn.prepareStatement(sql)
        val rs: ResultSet = stmt.executeQuery()

        println("Art√≠culos:")
        println("C√≥digo\tDescripci√≥n\tPrecio\tStock\tStock m√≠n.")

        while (rs.next()) {
            val codA = rs.getString("cod_a")
            val descrip = rs.getString("descrip")
            val preu = rs.getDouble("preu")
            val stock = rs.getInt("stock")
            val stockMin = rs.getInt("stock_min")

            println("$codA\t$descrip\t$preu\t$stock\t$stockMin")
        }

        rs.close()
        stmt.close()
        conn.close()
    }
</code></pre>
<p><strong>Ejemplo_cierre_try_catch.kt:</strong> Cierra los reursos con try-catch-finally</p>
<pre><code>    package SQLite
    import java.sql.Connection
    import java.sql.DriverManager
    import java.sql.PreparedStatement
    import java.sql.ResultSet

    fun main() {
        val dbPath = "src/main/resources/Tienda.sqlite"
        val dbFile = java.io.File(dbPath)
        val url = "jdbc:sqlite:${dbFile.absolutePath}"

        var conn: Connection? = null
        var stmt: PreparedStatement? = null
        var rs: ResultSet? = null

        try {
            conn = DriverManager.getConnection(url)
            val sql = "SELECT cod_a, descrip, preu, stock, stock_min FROM article"
            stmt = conn.prepareStatement(sql)
            rs = stmt.executeQuery()

            println("Art√≠culos:")
            println("C√≥digo\tDescripci√≥n\tPrecio\tStock\tStock m√≠n.")

            while (rs.next()) {
                val codA = rs.getString("cod_a")
                val descrip = rs.getString("descrip")
                val preu = rs.getDouble("preu")
                val stock = rs.getInt("stock")
                val stockMin = rs.getInt("stock_min")

                println("$codA\t$descrip\t$preu\t$stock\t$stockMin")
            }

        } catch (e: Exception) {
            println("Error al acceder a la base de datos: ${e.message}")
        } finally {
            try { rs?.close() } catch (e: Exception) { /* Ignorar */ }
            try { stmt?.close() } catch (e: Exception) { /* Ignorar */ }
            try { conn?.close() } catch (e: Exception) { /* Ignorar */ }
        }
    }
</code></pre>
<h2 id="crud-postgresql">üîπCRUD - PostgreSQL<a class="headerlink" href="#crud-postgresql" title="Permanent link">&para;</a></h2>
<p>Hasta ahora hemos trabajado con ejemplos de operaciones <strong>CRUD</strong> (Crear, Leer, Actualizar y Borrar) utilizando <strong>SQLite</strong>, una base de datos ligera, f√°cil de usar y sin necesidad de servidor, ideal para iniciarse en el acceso a datos desde Kotlin.</p>
<p>Sin embargo, en entornos reales y profesionales, lo m√°s habitual es trabajar con sistemas de gesti√≥n de bases de datos m√°s potentes y completos, como <strong>PostgreSQL</strong>.</p>
<p>A continuaci√≥n, aplicaremos lo aprendido en SQLite, pero ahora trabajando con <strong>PostgreSQL</strong> en <strong>dos contextos distintos</strong>:</p>
<ul>
<li>Base de datos <strong>remota</strong>: alojada en un servidor accesible mediante una direcci√≥n IP y credenciales.</li>
<li>Base de datos <strong>local</strong>: replicada en un contenedor <strong>Docker</strong>, lo que resulta ideal para pruebas, desarrollo y aprendizaje en un entorno controlado.</li>
</ul>
<p>En ambos casos utilizaremos la misma base de datos, llamada <strong>geo_ad</strong>. Su versi√≥n remota estar√° disponible desde cualquier ubicaci√≥n, mientras que la local se generar√° a partir de ella siguiendo unas instrucciones que se os facilitar√°n.</p>
<p><strong class="azul">Esquema de la BD geo_ad</strong> </p>
<table>
<thead>
<tr>
<th>Modelo Relacional - Datos</th>
<th>Paquete Postgres</th>
</tr>
</thead>
<tbody>
<tr>
<td><img alt="ref" src="../img/geo_ad.jpg" /></td>
<td><img alt="ref" src="../img/carpeta_postgres.png" /></td>
</tr>
</tbody>
</table>
<div class="admonition tip">
<p class="admonition-title">Kotlin - Instrucciones</p>
<p>Dentro del paquete <code>Postgres</code> del proyecto <code>BDRelacionales</code>, incluiremos los ejemplos de este apartado. Estos ejemplos mostrar√°n c√≥mo gestionar datos desde una aplicaci√≥n en Kotlin conectada a una base de datos relacional, utilizando las tablas <code>institut</code>, <code>poblacio</code> y <code>comarca</code>, tal y como se aprecia en el modelo relacional de la siguiente imagen.   </p>
</div>
<p><strong class="azul">Configuraci√≥n de Dependencias (Gradle)</strong></p>
<p>Lo primero ser√° incluir las dependencia necesarias en <strong>build.gradle.kts</strong></p>
<pre><code>    // build.gradle.kts (para PostgreSQL)
    dependencies {
        implementation("org.postgresql:postgresql:42.6.0")
    }
</code></pre>
<h3 id="servidor-remoto">üóÑÔ∏èServidor remoto<a class="headerlink" href="#servidor-remoto" title="Permanent link">&para;</a></h3>
<p>La base de datos <strong>geo_ad</strong> se encuentra en una m√°quina externa, por lo que se comporta como un recurso compartido en la nube. Para acceder a ella necesitamos establecer una conexi√≥n de red utilizando par√°metros como los siguientes:</p>
<div class="admonition note">
<p class="admonition-title">Datos de conexi√≥n al servido remoto</p>
<p><strong>Servidor (host)</strong>: 89.36.214.106<br />
<strong>Port</strong>: 5432 (es el puerto por defecto)<br />
<strong>Usuari</strong>: geo_ad<br />
<strong>Contrasenya</strong>: geo_ad<br />
<strong>Base de dades</strong>: geo_ad  </p>
</div>
<p><strong>Ejemplo_conexion_Postgres_remota.kt</strong></p>
<pre><code>    package Postgres
    import java.sql.DriverManager
    object DatabaseRemota {

        private const val URL =  "jdbc:postgresql://89.36.214.106:5432/geo_ad"
        private const val USER = "geo_ad"
        private const val PASSWORD = "geo_ad"

        fun getConnection() = DriverManager.getConnection(URL, USER, PASSWORD)
    }
</code></pre>
<p><strong class="azul">Operaciones CRUD</strong>     </p>
<p>Una vez conectados a la BD, ya podemos hacer operaciones CRUD sobre ella, utilizando el objeto de conexi√≥n correspondiente.</p>
<p><strong class="verde">Read (SELECT)</strong>     </p>
<p><strong>Ejemplo_Select.kt</strong>: Consulta todos los institutos</p>
<pre><code>        package Postgres
        fun main(args: Array&lt;String&gt;) {
        val sql = "SELECT * FROM institut"

        DatabaseLocal.getConnection().use { conn -&gt;    // DatabaseRemota si se conecta al servidor del instituto
                conn.prepareStatement(sql).use { stmt -&gt;
                stmt.executeQuery().use { rs -&gt;

                    while (rs.next()) {
                        print("" + rs.getString(1) + "\t")
                        println(rs.getString(2))
                    }
                }
            }
            }
         }
</code></pre>
<hr />
<p><strong class="verde">Create (INSERT)</strong>  </p>
<p><strong>Ejemplo_Insert.kt</strong>: inserta un istituto de prueba.</p>
<pre><code>    package Postgres
    fun main(args: Array&lt;String&gt;) {

        val sql ="INSERT INTO institut (codi,nom,adreca,numero,codpostal,cod_m) VALUES(?,?,?,?,?,?)"

        DatabaseLocal.getConnection().use { conn -&gt;

            conn.prepareStatement(sql).use { stmt -&gt;
                stmt.setString(1, "00000000")
                stmt.setString(2, "IES PRUEBA")
                stmt.setString(3, "CASTELL√ìN")
                stmt.setString(4, "S/N")
                stmt.setInt(5, 12560)
                stmt.setInt(6, 12040)
                stmt.executeUpdate()
            }
        }
    }
</code></pre>
<p><strong class="verde">Update (UPDATE)</strong>    </p>
<p><strong>Ejemplo_Update.kt</strong>: actualiza el campo nombre del instituto de prueba insertado.</p>
<pre><code>    package Postgres
    fun main() {
        val sql = "UPDATE institut SET nom = ? WHERE codi = ?"

        DatabaseLocal.getConnection().use { conn -&gt;

            conn.prepareStatement(sql).use { stmt -&gt;
                stmt.setString(1, "IES PRUEBA 2")
                stmt.setString(2, "00000000")
                stmt.executeUpdate()
            }
        }
    }
</code></pre>
<p><strong class="verde">Delete (DELETE)</strong>   </p>
<p><strong>Ejemplo_Delete.kt</strong>: elimina el instituto de prueba insertado anteriormente.</p>
<pre><code>    package Postgres
    fun main() {
        val sql = "DELETE FROM institut WHERE codi = ?"

        DatabaseLocal.getConnection().use { conn -&gt;

            conn.prepareStatement(sql).use { stmt -&gt;
                stmt.setString(1, "00000000")
                stmt.executeUpdate()
            }
        }
    }
</code></pre>
<h3 id="docker">üê≥ Docker<a class="headerlink" href="#docker" title="Permanent link">&para;</a></h3>
<p>Para poder programar y probar nuestras aplicaciones sin depender de la conexi√≥n externa, es muy √∫til replicar esa base de datos en local. La forma m√°s sencilla y estandarizada de hacerlo es mediante <strong>Docker</strong>.</p>
<ul>
<li>Docker es una plataforma que permite ejecutar aplicaciones dentro de contenedores.</li>
<li>Un contenedor es como una ‚Äúcaja‚Äù que incluye todo lo necesario para que un servicio funcione: sistema operativo reducido, librer√≠as, configuraci√≥n y la propia aplicaci√≥n.</li>
<li>Para bases de datos, existen im√°genes oficiales (Postgres, MySQL, MongoDB‚Ä¶) que se pueden levantar en segundos.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Intrucciones para replicar la BD en local (Docker)</p>
<p>Las instrucciones para replicar la base de datos en Docker las pod√©is encontrar en el siguiente enlace: <a href="../Docker_instrucciones/">Instrucciones</a>    </p>
</div>
<hr />
<p>üîå Una vez hemos creada la BD en local ya podemos conectarnos a ella:    </p>
<p><strong>Ejemplo_conexion_Postgres_local.kt</strong></p>
<pre><code>    package Postgres
    import java.sql.DriverManager
    object DatabaseLocal {

        private const val URL =  "jdbc:postgresql://localhost:5432/geo"
        private const val USER = "postgres"
        private const val PASSWORD = "postgres"

        fun getConnection() = DriverManager.getConnection(URL, USER, PASSWORD)
    }
</code></pre>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Los ejemplos anteriores de operaciones CRUD, realizados sobre el servidor remoto, son igualmente v√°lidos para el servidor local, ya que la base de datos es la misma.</p>
</div>
<h2 id="data-class">üîπData Class<a class="headerlink" href="#data-class" title="Permanent link">&para;</a></h2>
<p>Hasta ahora hemos trabajado con bases de datos relacionales utilizando JDBC, construyendo consultas SQL, procesando los resultados con ResultSet y mostrando la informaci√≥n directamente por consola o almacen√°ndola en estructuras b√°sicas como listas o mapas.</p>
<p>Sin embargo, cuando una aplicaci√≥n crece, se vuelve m√°s c√≥modo y legible representar cada tabla de la base de datos como una clase del programa, cuyos atributos correspondan a las columnas de esa tabla.
En <strong>Kotlin</strong>, esto se consigue de forma sencilla y elegante utilizando las <strong>data classes</strong>.</p>
<p>Una <strong>data class</strong> (o clase de datos) es una clase especial de Kotlin dise√±ada para almacenar y transportar informaci√≥n.
El compilador genera autom√°ticamente m√©todos √∫tiles como toString(), equals(), hashCode() y copy(), por lo que resulta ideal para representar filas (registros) de una tabla de base de datos.</p>
<p>Su sint√°xis b√°sica es:</p>
<pre><code>    data class NombreClase(val campo1: Tipo, val campo2: Tipo, ...)
</code></pre>
<p>üß© <strong>Ejemplo</strong>: representaci√≥n de una tabla cliente</p>
<p>Supongamos que en la base de datos existe una tabla:</p>
<pre><code>    CREATE TABLE cliente (
        id INTEGER PRIMARY KEY,
        nombre TEXT,
        email TEXT
    );
</code></pre>
<p>Podemos definir la siguiente clase en Kotlin:</p>
<pre><code>    data class Cliente(
        val id: Int,
        val nombre: String,
        val email: String
    )
</code></pre>
<p>Y al realizar una consulta con JDBC:</p>
<pre><code>    val clientes = mutableListOf&lt;Cliente&gt;()
    val rs = stmt.executeQuery("SELECT * FROM cliente")

    while (rs.next()) {
        clientes.add(
            Cliente(
                id = rs.getInt("id"),
                nombre = rs.getString("nombre"),
                email = rs.getString("email")
            )
        )
    }
</code></pre>
<p>En este ejemplo:</p>
<ul>
<li>Cada fila del ResultSet se convierte en un objeto Cliente.</li>
<li>Todos los clientes recuperados se almacenan en una lista tipada (<code>List&lt;Cliente&gt;</code>).</li>
<li>Posteriormente se pueden mostrar, modificar o procesar con facilidad.</li>
</ul>
<h3 id="uso-de-data-class-en-la-bd-geo">üìå <strong>Uso de <code>data class</code> en la BD Geo</strong><a class="headerlink" href="#uso-de-data-class-en-la-bd-geo" title="Permanent link">&para;</a></h3>
<p>En este ejemplo replicamos la misma consulta que ya vimos anteriormente para obtener todos los institutos de la base de datos <strong>geo_ad</strong> alojada en el servidor remoto, pero ahora utilizando un <strong><code>data class</code></strong> en Kotlin. </p>
<p>Esto nos permite representar cada fila del resultado como un objeto de tipo <code>Institut</code>, facilitando el tratamiento, la reutilizaci√≥n y la lectura del c√≥digo.</p>
<p>Adem√°s, almacenamos los resultados en una lista de objetos, lo que nos permite trabajar con ellos de forma m√°s natural dentro de nuestro programa (listar, filtrar, transformar, etc.).</p>
<p><strong>Data Class: Institut</strong></p>
<pre><code>package Postgres

    data class Institut(
        val codi: String,
        val nom: String?,
        val adreca: String?,
        val numero: String?,
        val codpostal: Int?,
        val codMunicipi: Int?
    )
</code></pre>
<p><strong>Ejemplo_dataclass.kt</strong></p>
<pre><code>package Postgres

    fun main() {
        val sql = "SELECT * FROM institut"

        val instituts = mutableListOf&lt;Institut&gt;()

        DatabaseRemota.getConnection().use { conn -&gt;  // Usa DatabaseRemota si es necesario
            conn.prepareStatement(sql).use { stmt -&gt;
                stmt.executeQuery().use { rs -&gt;
                    while (rs.next()) {
                        val institut = Institut(
                            rs.getString("codi"),
                            rs.getString("nom"),
                            rs.getString("adreca"),
                            rs.getString("numero"),
                            rs.getInt("codpostal"),
                            rs.getInt("cod_m")
                        )
                        instituts.add(institut)
                    }
                }
            }
        }

        println("üè´ Institutos encontrados:")
        instituts.forEach { println(it) }
    }
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../Conectores/" class="btn btn-neutral float-left" title="üîπHerramientas y Conectores"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../Transacciones/" class="btn btn-neutral float-right" title="üîπTransacciones y control de errores">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../Conectores/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../Transacciones/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../js/copy-button.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
