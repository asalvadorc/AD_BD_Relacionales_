{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bases de Datos Relacionales \u00b6","title":"Acceso a Datos - Bases de Datos Relacionales"},{"location":"#bases-de-datos-relacionales","text":"","title":"Bases de Datos Relacionales"},{"location":"Conectores/","text":"Herramientas y Conectores \u00b6 De todas las formas posibles de interactuar con una base de datos, nos vamos a centrar en el uso de conectores , porque son la forma m\u00e1s directa y habitual de acceder a la base de datos desde un lenguaje de programaci\u00f3n, como Kotlin, que es el que estamos utilizando en este m\u00f3dulo. En la introducci\u00f3n ya vimos que un conector (tambi\u00e9n llamado driver) es una librer\u00eda software que permite que una aplicaci\u00f3n se comunique con un gestor de base de datos (SGBD). Act\u00faa como un puente entre nuestro c\u00f3digo y la base de datos, traduciendo las instrucciones SQL a un lenguaje que el gestor puede entender y viceversa. Sin un conector, tu aplicaci\u00f3n no podr\u00eda comunicarse con la base de datos. En herramientas gr\u00e1ficas como DBeaver , los drivers se gestionan autom\u00e1ticamente. En proyectos en c\u00f3digo , se a\u00f1aden como dependencia (por ejemplo, en Maven, Gradle, pip\u2026). Una base de datos puede ser accedida desde diferentes or\u00edgenes o herramientas, siempre que tengamos: Las credenciales de acceso (usuario y contrase\u00f1a) El host/servidor donde se encuentra la base de datos El motor de base de datos (PostgreSQL, MySQL, SQLite, etc.) Los puertos habilitados y los permisos correctos Principales formas de conectarse a una base de datos Medio de conexi\u00f3n Descripci\u00f3n \ud83d\udda5\ufe0f Aplicaciones de escritorio Herramientas gr\u00e1ficas como DBeaver , pgAdmin , MySQL Workbench , DB Browser for SQLite . Permiten explorar, consultar y administrar BD de forma visual. \ud83d\udcbb Aplicaciones desarrolladas en c\u00f3digo Programas en Kotlin , Java , Python , C# , etc., mediante conectores como JDBC , psycopg2 , ODBC , etc. para acceder a BD desde c\u00f3digo. \ud83d\udd20 L\u00ednea de comandos Clientes como psql (PostgreSQL), mysql , sqlite3 . Permiten ejecutar comandos SQL directamente desde terminal. \ud83c\udf10 Aplicaciones web Sitios web que acceden a BD desde el backend (por ejemplo, en Spring Boot, Node.js, Django, etc.). \ud83d\udd04 APIs REST o servidores intermedios Servicios web que conectan la BD con otras aplicaciones, actuando como puente o capa de seguridad. \ud83d\udcf1 Aplicaciones m\u00f3viles Apps Android/iOS que acceden a BD locales (como SQLite ) o remotas (v\u00eda Firebase , API REST, etc.). \ud83d\udcc2 Herramientas de integraci\u00f3n de datos Software como Talend , Pentaho , Apache Nifi para migrar, transformar o sincronizar datos entre sistemas. \ud83d\udd39JDBC \u00b6 JDBC (Java Database Connectivity) es una API est\u00e1ndar de Java que permite a los programas escritos en Java (y por extensi\u00f3n en Kotlin) conectarse y trabajar con bases de datos relacionales. Driver JDBC : cada gestor de BD proporciona un \"driver\" espec\u00edfico (un .jar) que implementa la interfaz de JDBC. mysql-connector-j, postgresql-42.x.jar, sqlite-jdbc.jar. URL de conexi\u00f3n : se usa una cadena con formato jdbc:<gestor>://<host>:<puerto>/<nombre_base_datos> para indicar c\u00f3mo llegar a la BD. Gestor de Base de Datos URL de conexi\u00f3n PostgreSQL jdbc:postgresql://localhost:5432/empresa MySQL jdbc:mysql://localhost:3306/empresa SQLite jdbc:sqlite:empresa.sqlite C\u00f3digo est\u00e1ndar : gracias a JDBC, el mismo c\u00f3digo Java/Kotlin puede trabajar con distintas bases de datos cambiando solo la URL y el driver. En los siguientes apartados veremos como conectarnos a una BD Relacional, tanto desde la herramienta gr\u00e1fica de BD integrada de IntelliJ como desde la herramienta universal para la gesti\u00f3n de bases de datos DBeaver y tambi\u00e9n desde una aplicaci\u00f3n desarrollada en Kotlin . \ud83d\udd39Desde IntellJ \u00b6 IntelliJ incorpora una potente herramienta de gesti\u00f3n de bases de datos que permite visualizar la base de datos directamente desde el entorno de desarrollo (IDE), lo que permite: \ud83d\udcc2 Explorar la estructura de la base de datos (tablas, vistas, claves, relaciones\u2026) \ud83d\udd0e Consultar datos en tiempo real con editores SQL integrados \ud83d\udee0\ufe0f Modificar tablas, a\u00f1adir registros o ejecutar scripts SQL sin salir del proyecto \u26a1 Ver los cambios reflejados inmediatamente tras ejecutar una operaci\u00f3n desde el c\u00f3digo \u2705 Probar consultas antes de implementarlas en el programa La siguientes im\u00e1genes ilustran como configura esta herramienta para conectarnos a la BD de ejemplo Tienda.sqlite , disponible en Aules: 1. Crea un nuevo proyecto en Kotlin y Gradle Al nuevo proyecto lo llamaremos BDRelacionales . 2. Copia el archivo de la BD a nuestro proyecto La ubicaremos en la carpeta resources . Esta carpeta forma parte del classpath del proyecto. All\u00ed se colocan archivos que necesita la aplicaci\u00f3n en tiempo de ejecuci\u00f3n. Cuando compilas el proyecto , todo lo que est\u00e1 en resources/ se copia dentro del jar o build final en la carpeta classes , manteniendo la misma estructura. Adem\u00e1s, Si compartes el proyecto, la base de datos viaja con \u00e9l. 3. Elige el conector a la base de datos En la herramienta Database -> Data Source elegimos el conector SQLite . 4. Selecciona la ubicaci\u00f3n de la BD Podemos comprobar la conexi\u00f3n en Test Concection antes de aceptar. Al aceptar, se nos pedir\u00e1 que instalemos el driver correspondiente, si no estuviera instalado. 5. Comprueba consultas antes de implementarlas Una vez configurado el acceso a la BD podemos ver en diferentes ventanas la estructura de la BD y el resultado de ejecutar las sentencias SQL, haciendo click derecho sobre la conexi\u00f3n y seleccionando la opci\u00f3n New > QueryConsole . \ud83d\udd39Desde DBeaver \u00b6 DBeaver es una herramienta gr\u00e1fica y gratuita que permite gestionar m\u00faltiples bases de datos de forma visual. Los pasos para conectarse a la BD Tienda.sqlite , disponible en Aules, son los siguientes: 1. Abre DBeaver Inicia el programa DBeaver . Aparecer\u00e1 la ventana principal con el panel lateral de conexiones. Haz clic en el bot\u00f3n \"Nueva conexi\u00f3n\" (\u00edcono de enchufe) o ve al men\u00fa Archivo > Nueva conexi\u00f3n . 2. Selecciona el tipo de base de datos En la ventana de selecci\u00f3n, elige SQlite y pulsa Siguiente . 3. Introduce la ruta donde se encuentra la BD 4. Prueba la conexi\u00f3n Haz clic en \"Probar conexi\u00f3n\" . Si todo est\u00e1 correcto, ver\u00e1s un mensaje de \u00e9xito. Si DBeaver necesita un controlador (driver), te lo ofrecer\u00e1 para descargar autom\u00e1ticamente. 5. Finaliza y explora Haz clic en \"Finalizar\" . La nueva conexi\u00f3n aparecer\u00e1 en el panel lateral izquierdo. Desde all\u00ed puedes: Ver tablas, vistas, funciones y procedimientos Ejecutar sentencias SQL Consultar y modificar registros Exportar datos en distintos formatos \ud83d\udd39Desde Kotlin \u00b6 Para que una aplicaci\u00f3n (escrita en Kotlin, Java u otro lenguaje) pueda leer, insertar o modificar informaci\u00f3n almacenada en una base de datos relacional (BDR), debe establecer una conexi\u00f3n con ella. Esto implica una serie de pasos t\u00e9cnicos y el uso de componentes espec\u00edficos: Conectarse al gestor de base de datos (PostgreSQL, MySQL, SQLite\u2026) Enviar consultas SQL (SELECT, INSERT, UPDATE, DELETE\u2026) Recibir y procesar resultados (ResultSet, listas de objetos\u2026) Cerrar correctamente los recursos utilizados Kotlin - Instrucciones En el proyecto BDRelacionales , ya creado y conectado a la BD Tienda.sqlite, crearemos un paquete nuevo llamado SQLite . En este paquete incluiremos los ejemplos de este apartado. Para que la conexi\u00f3n funcione, es necesario a\u00f1adir el conector jdbc correspondiente. Para ello utilizaremos la herramienta Gradle , que permite automatizar la gesti\u00f3n de dependencias sin tener que configurar nada a mano. build.gradle.kts : dependencies { implementation(\"org.postgresql:postgresql:42.7.1\") //Postgres implementation(\"mysql:mysql-connector-java:8.3.0\") //MySQL implementation(\"org.xerial:sqlite-jdbc:3.43.0.0\") //SQLite } Ejemplo de conexi\u00f3n a SQLite Ejemplo_Conexion_SQLite.kt : El siguiente programa conecta con la BD Tienda.sqlite . import java.io.File import java.sql.DriverManager fun main() { // Ruta al archivo de base de datos SQLite val dbPath = \"src/main/resources/Tienda.sqlite\" val dbFile = File(dbPath) println(\"Ruta de la BD: ${dbFile.absolutePath}\") val url = \"jdbc:sqlite:${dbFile.absolutePath}\" // Conexi\u00f3n y prueba DriverManager.getConnection(url).use { conn -> println(\"Conexi\u00f3n establecida correctamente con SQLite.\") } } Recuerda No se necesita usuario ni contrase\u00f1a con SQLite, ya que es una base de datos local y embebida. Podemos encapsular la conexi\u00f3n a la base de datos dentro de un objeto, de manera que pueda reutilizarse tantas veces como sea necesario. As\u00ed evitamos duplicar c\u00f3digo y reducimos posibles errores. Por ejemplo, si la base de datos cambia de ubicaci\u00f3n, solo habr\u00eda que actualizar la ruta en el objeto y no en cada uno de los programas. Ejemplo_Conexion_SQLite_obj.kt import java.io.File import java.sql.DriverManager object DatabaseTienda { // Ruta al archivo de base de datos SQLite val dbPath = \"src/main/resources/Tienda.sqlite\" val dbFile = File(dbPath) val url = \"jdbc:sqlite:${dbFile.absolutePath}\" fun getConnection() = DriverManager.getConnection(url) } Ejemplo_basico_conexion_objeto.kt import java.io.File import java.sql.DriverManager import kotlin.use fun main() { val sql = \"SELECT * FROM article\" DatabaseTienda.getConnection().use { conn -> conn.prepareStatement(sql).use { stmt -> stmt.executeQuery().use { rs -> while (rs.next()) { //c\u00f3digo } } } } }","title":"\ud83d\udd39Herramientas y Conectores"},{"location":"Conectores/#herramientas-y-conectores","text":"De todas las formas posibles de interactuar con una base de datos, nos vamos a centrar en el uso de conectores , porque son la forma m\u00e1s directa y habitual de acceder a la base de datos desde un lenguaje de programaci\u00f3n, como Kotlin, que es el que estamos utilizando en este m\u00f3dulo. En la introducci\u00f3n ya vimos que un conector (tambi\u00e9n llamado driver) es una librer\u00eda software que permite que una aplicaci\u00f3n se comunique con un gestor de base de datos (SGBD). Act\u00faa como un puente entre nuestro c\u00f3digo y la base de datos, traduciendo las instrucciones SQL a un lenguaje que el gestor puede entender y viceversa. Sin un conector, tu aplicaci\u00f3n no podr\u00eda comunicarse con la base de datos. En herramientas gr\u00e1ficas como DBeaver , los drivers se gestionan autom\u00e1ticamente. En proyectos en c\u00f3digo , se a\u00f1aden como dependencia (por ejemplo, en Maven, Gradle, pip\u2026). Una base de datos puede ser accedida desde diferentes or\u00edgenes o herramientas, siempre que tengamos: Las credenciales de acceso (usuario y contrase\u00f1a) El host/servidor donde se encuentra la base de datos El motor de base de datos (PostgreSQL, MySQL, SQLite, etc.) Los puertos habilitados y los permisos correctos Principales formas de conectarse a una base de datos Medio de conexi\u00f3n Descripci\u00f3n \ud83d\udda5\ufe0f Aplicaciones de escritorio Herramientas gr\u00e1ficas como DBeaver , pgAdmin , MySQL Workbench , DB Browser for SQLite . Permiten explorar, consultar y administrar BD de forma visual. \ud83d\udcbb Aplicaciones desarrolladas en c\u00f3digo Programas en Kotlin , Java , Python , C# , etc., mediante conectores como JDBC , psycopg2 , ODBC , etc. para acceder a BD desde c\u00f3digo. \ud83d\udd20 L\u00ednea de comandos Clientes como psql (PostgreSQL), mysql , sqlite3 . Permiten ejecutar comandos SQL directamente desde terminal. \ud83c\udf10 Aplicaciones web Sitios web que acceden a BD desde el backend (por ejemplo, en Spring Boot, Node.js, Django, etc.). \ud83d\udd04 APIs REST o servidores intermedios Servicios web que conectan la BD con otras aplicaciones, actuando como puente o capa de seguridad. \ud83d\udcf1 Aplicaciones m\u00f3viles Apps Android/iOS que acceden a BD locales (como SQLite ) o remotas (v\u00eda Firebase , API REST, etc.). \ud83d\udcc2 Herramientas de integraci\u00f3n de datos Software como Talend , Pentaho , Apache Nifi para migrar, transformar o sincronizar datos entre sistemas.","title":"Herramientas y Conectores"},{"location":"Conectores/#jdbc","text":"JDBC (Java Database Connectivity) es una API est\u00e1ndar de Java que permite a los programas escritos en Java (y por extensi\u00f3n en Kotlin) conectarse y trabajar con bases de datos relacionales. Driver JDBC : cada gestor de BD proporciona un \"driver\" espec\u00edfico (un .jar) que implementa la interfaz de JDBC. mysql-connector-j, postgresql-42.x.jar, sqlite-jdbc.jar. URL de conexi\u00f3n : se usa una cadena con formato jdbc:<gestor>://<host>:<puerto>/<nombre_base_datos> para indicar c\u00f3mo llegar a la BD. Gestor de Base de Datos URL de conexi\u00f3n PostgreSQL jdbc:postgresql://localhost:5432/empresa MySQL jdbc:mysql://localhost:3306/empresa SQLite jdbc:sqlite:empresa.sqlite C\u00f3digo est\u00e1ndar : gracias a JDBC, el mismo c\u00f3digo Java/Kotlin puede trabajar con distintas bases de datos cambiando solo la URL y el driver. En los siguientes apartados veremos como conectarnos a una BD Relacional, tanto desde la herramienta gr\u00e1fica de BD integrada de IntelliJ como desde la herramienta universal para la gesti\u00f3n de bases de datos DBeaver y tambi\u00e9n desde una aplicaci\u00f3n desarrollada en Kotlin .","title":"\ud83d\udd39JDBC"},{"location":"Conectores/#desde-intellj","text":"IntelliJ incorpora una potente herramienta de gesti\u00f3n de bases de datos que permite visualizar la base de datos directamente desde el entorno de desarrollo (IDE), lo que permite: \ud83d\udcc2 Explorar la estructura de la base de datos (tablas, vistas, claves, relaciones\u2026) \ud83d\udd0e Consultar datos en tiempo real con editores SQL integrados \ud83d\udee0\ufe0f Modificar tablas, a\u00f1adir registros o ejecutar scripts SQL sin salir del proyecto \u26a1 Ver los cambios reflejados inmediatamente tras ejecutar una operaci\u00f3n desde el c\u00f3digo \u2705 Probar consultas antes de implementarlas en el programa La siguientes im\u00e1genes ilustran como configura esta herramienta para conectarnos a la BD de ejemplo Tienda.sqlite , disponible en Aules: 1. Crea un nuevo proyecto en Kotlin y Gradle Al nuevo proyecto lo llamaremos BDRelacionales . 2. Copia el archivo de la BD a nuestro proyecto La ubicaremos en la carpeta resources . Esta carpeta forma parte del classpath del proyecto. All\u00ed se colocan archivos que necesita la aplicaci\u00f3n en tiempo de ejecuci\u00f3n. Cuando compilas el proyecto , todo lo que est\u00e1 en resources/ se copia dentro del jar o build final en la carpeta classes , manteniendo la misma estructura. Adem\u00e1s, Si compartes el proyecto, la base de datos viaja con \u00e9l. 3. Elige el conector a la base de datos En la herramienta Database -> Data Source elegimos el conector SQLite . 4. Selecciona la ubicaci\u00f3n de la BD Podemos comprobar la conexi\u00f3n en Test Concection antes de aceptar. Al aceptar, se nos pedir\u00e1 que instalemos el driver correspondiente, si no estuviera instalado. 5. Comprueba consultas antes de implementarlas Una vez configurado el acceso a la BD podemos ver en diferentes ventanas la estructura de la BD y el resultado de ejecutar las sentencias SQL, haciendo click derecho sobre la conexi\u00f3n y seleccionando la opci\u00f3n New > QueryConsole .","title":"\ud83d\udd39Desde IntellJ"},{"location":"Conectores/#desde-dbeaver","text":"DBeaver es una herramienta gr\u00e1fica y gratuita que permite gestionar m\u00faltiples bases de datos de forma visual. Los pasos para conectarse a la BD Tienda.sqlite , disponible en Aules, son los siguientes: 1. Abre DBeaver Inicia el programa DBeaver . Aparecer\u00e1 la ventana principal con el panel lateral de conexiones. Haz clic en el bot\u00f3n \"Nueva conexi\u00f3n\" (\u00edcono de enchufe) o ve al men\u00fa Archivo > Nueva conexi\u00f3n . 2. Selecciona el tipo de base de datos En la ventana de selecci\u00f3n, elige SQlite y pulsa Siguiente . 3. Introduce la ruta donde se encuentra la BD 4. Prueba la conexi\u00f3n Haz clic en \"Probar conexi\u00f3n\" . Si todo est\u00e1 correcto, ver\u00e1s un mensaje de \u00e9xito. Si DBeaver necesita un controlador (driver), te lo ofrecer\u00e1 para descargar autom\u00e1ticamente. 5. Finaliza y explora Haz clic en \"Finalizar\" . La nueva conexi\u00f3n aparecer\u00e1 en el panel lateral izquierdo. Desde all\u00ed puedes: Ver tablas, vistas, funciones y procedimientos Ejecutar sentencias SQL Consultar y modificar registros Exportar datos en distintos formatos","title":"\ud83d\udd39Desde DBeaver"},{"location":"Conectores/#desde-kotlin","text":"Para que una aplicaci\u00f3n (escrita en Kotlin, Java u otro lenguaje) pueda leer, insertar o modificar informaci\u00f3n almacenada en una base de datos relacional (BDR), debe establecer una conexi\u00f3n con ella. Esto implica una serie de pasos t\u00e9cnicos y el uso de componentes espec\u00edficos: Conectarse al gestor de base de datos (PostgreSQL, MySQL, SQLite\u2026) Enviar consultas SQL (SELECT, INSERT, UPDATE, DELETE\u2026) Recibir y procesar resultados (ResultSet, listas de objetos\u2026) Cerrar correctamente los recursos utilizados Kotlin - Instrucciones En el proyecto BDRelacionales , ya creado y conectado a la BD Tienda.sqlite, crearemos un paquete nuevo llamado SQLite . En este paquete incluiremos los ejemplos de este apartado. Para que la conexi\u00f3n funcione, es necesario a\u00f1adir el conector jdbc correspondiente. Para ello utilizaremos la herramienta Gradle , que permite automatizar la gesti\u00f3n de dependencias sin tener que configurar nada a mano. build.gradle.kts : dependencies { implementation(\"org.postgresql:postgresql:42.7.1\") //Postgres implementation(\"mysql:mysql-connector-java:8.3.0\") //MySQL implementation(\"org.xerial:sqlite-jdbc:3.43.0.0\") //SQLite } Ejemplo de conexi\u00f3n a SQLite Ejemplo_Conexion_SQLite.kt : El siguiente programa conecta con la BD Tienda.sqlite . import java.io.File import java.sql.DriverManager fun main() { // Ruta al archivo de base de datos SQLite val dbPath = \"src/main/resources/Tienda.sqlite\" val dbFile = File(dbPath) println(\"Ruta de la BD: ${dbFile.absolutePath}\") val url = \"jdbc:sqlite:${dbFile.absolutePath}\" // Conexi\u00f3n y prueba DriverManager.getConnection(url).use { conn -> println(\"Conexi\u00f3n establecida correctamente con SQLite.\") } } Recuerda No se necesita usuario ni contrase\u00f1a con SQLite, ya que es una base de datos local y embebida. Podemos encapsular la conexi\u00f3n a la base de datos dentro de un objeto, de manera que pueda reutilizarse tantas veces como sea necesario. As\u00ed evitamos duplicar c\u00f3digo y reducimos posibles errores. Por ejemplo, si la base de datos cambia de ubicaci\u00f3n, solo habr\u00eda que actualizar la ruta en el objeto y no en cada uno de los programas. Ejemplo_Conexion_SQLite_obj.kt import java.io.File import java.sql.DriverManager object DatabaseTienda { // Ruta al archivo de base de datos SQLite val dbPath = \"src/main/resources/Tienda.sqlite\" val dbFile = File(dbPath) val url = \"jdbc:sqlite:${dbFile.absolutePath}\" fun getConnection() = DriverManager.getConnection(url) } Ejemplo_basico_conexion_objeto.kt import java.io.File import java.sql.DriverManager import kotlin.use fun main() { val sql = \"SELECT * FROM article\" DatabaseTienda.getConnection().use { conn -> conn.prepareStatement(sql).use { stmt -> stmt.executeQuery().use { rs -> while (rs.next()) { //c\u00f3digo } } } } }","title":"\ud83d\udd39Desde Kotlin"},{"location":"Docker_instrucciones/","text":"\ud83d\udc18 Instalaci\u00f3n y configuraci\u00f3n de PostgreSQL con Docker y DBeaver \u00b6 \ud83d\udccb Resumen de la pr\u00e1ctica \u00b6 Se instala PostgreSQL con Docker usando un docker-compose.yml . Se arranca el contenedor y se verifica con docker ps . Se conecta la base de datos con DBeaver ( localhost:5432 ). Se crean las tablas COMARCA , POBLACIO e INSTITUT . Se insertan los datos iniciales desde los scripts .sql . 1\ufe0f\u20e3 Instalaci\u00f3n de PostgreSQL con Docker \u00b6 Para crear un contenedor de PostgreSQL en nuestro equipo utilizaremos Docker Compose . \ud83d\udca1 Si eres usuario de Windows o Mac , instala Docker Desktop . Si usas Ubuntu o Debian , aseg\u00farate de tener instalado docker y docker-compose . 1.1. Crear el archivo docker-compose.yml \u00b6 En una carpeta llamada, por ejemplo, docker/postgres , crea un archivo con el siguiente contenido: version: '3.8' services: db: image: postgres:16.4 container_name: mi_postgres environment: POSTGRES_PASSWORD: postgres POSTGRES_USER: postgres POSTGRES_DB: geo volumes: - db_data:/var/lib/postgresql/data ports: - \"5432:5432\" volumes: db_data: 1.2. Levantar el servicio \u00b6 Posici\u00f3nate en el terminal en el directorio donde est\u00e1 el fichero docker-compose.yml y ejecuta: docker-compose up -d 1.3. Verificar el contenedor \u00b6 Para comprobar que PostgreSQL est\u00e1 activo, ejecuta en el terminal: docker ps El resultado debe mostrar una entrada similar a la siguiente: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 327fd50443a7 postgres:8 \"docker-entrypoint.s\u2026\" 29 hours ago Up 6 hours 0.0.0.0:5432->5432/tcp docker_postgres Si aparece el contenedor mi_postgres con estado Up, significa que el servicio de PostgreSQL est\u00e1 funcionando correctamente. 2\ufe0f\u20e3 Conexi\u00f3n de PostgreSQL con DBeaver \u00b6 Una vez el contenedor de PostgreSQL est\u00e1 activo, podemos conectarnos mediante el cliente gr\u00e1fico DBeaver . 2.1. Crear nueva conexi\u00f3n \u00b6 Abre DBeaver . Selecciona Nueva conexi\u00f3n \u2192 PostgreSQL . Introduce los siguientes datos de conexi\u00f3n: Campo Valor Nombre de conexi\u00f3n docker-geo Server host localhost Port 5432 Database geo User name postgres Password postgres Haz clic en Test Connection para comprobar la conexi\u00f3n. Si la prueba es satisfactoria, guarda la conexi\u00f3n. 3\ufe0f\u20e3 Creaci\u00f3n de la base de datos geo \u00b6 En la conexi\u00f3n local de PostgreSQL (ya desde DBeaver o cualquier cliente SQL), ejecuta los siguientes scripts para crear las tablas del esquema public . 3.1. Creaci\u00f3n de la tabla COMARCA \u00b6 CREATE TABLE public.comarca ( nom_c varchar(50) NOT NULL, provincia varchar(25) NULL, CONSTRAINT cp_com PRIMARY KEY (nom_c) ); 3.2. Creaci\u00f3n de la tabla POBLACIO \u00b6 CREATE TABLE public.poblacio ( cod_m numeric(5) NOT NULL, nom varchar(50) NOT NULL, poblacio numeric(6) NULL, extensio numeric(6, 2) NULL, altura numeric(4) NULL, longitud varchar(50) NULL, latitud varchar(50) NULL, llengua bpchar(1) NULL, nom_c varchar(50) NULL, CONSTRAINT cp_pobl PRIMARY KEY (cod_m), CONSTRAINT ce_pob_com FOREIGN KEY (nom_c) REFERENCES public.comarca(nom_c) ON UPDATE CASCADE ); 3.3. Creaci\u00f3n de la tabla INSTITUT \u00b6 CREATE TABLE public.institut ( codi varchar(8) NOT NULL, nom varchar(60) NULL, adreca varchar(100) NULL, numero varchar(5) NULL, codpostal numeric(5) NULL, cod_m numeric(5) NULL, CONSTRAINT cp_ins PRIMARY KEY (codi), CONSTRAINT ce_ins_pob FOREIGN KEY (cod_m) REFERENCES public.poblacio(cod_m) ); 4\ufe0f\u20e3 Carga de datos iniciales \u00b6 Para completar la base de datos, ejecuta los siguientes scripts SQL desde DBeaver o desde el terminal de PostgreSQL . Cada script se encarga de insertar los datos de las tablas creadas previamente. \ud83d\udcc2 Inserci\u00f3n de comarcas \ud83d\udcc2 Inserci\u00f3n de poblacio \ud83d\udcc2 Inserci\u00f3n de insitut","title":"\ud83d\udc18 Instalaci\u00f3n y configuraci\u00f3n de PostgreSQL con Docker y DBeaver"},{"location":"Docker_instrucciones/#instalacion-y-configuracion-de-postgresql-con-docker-y-dbeaver","text":"","title":"\ud83d\udc18 Instalaci\u00f3n y configuraci\u00f3n de PostgreSQL con Docker y DBeaver"},{"location":"Docker_instrucciones/#resumen-de-la-practica","text":"Se instala PostgreSQL con Docker usando un docker-compose.yml . Se arranca el contenedor y se verifica con docker ps . Se conecta la base de datos con DBeaver ( localhost:5432 ). Se crean las tablas COMARCA , POBLACIO e INSTITUT . Se insertan los datos iniciales desde los scripts .sql .","title":"\ud83d\udccb Resumen de la pr\u00e1ctica"},{"location":"Docker_instrucciones/#1-instalacion-de-postgresql-con-docker","text":"Para crear un contenedor de PostgreSQL en nuestro equipo utilizaremos Docker Compose . \ud83d\udca1 Si eres usuario de Windows o Mac , instala Docker Desktop . Si usas Ubuntu o Debian , aseg\u00farate de tener instalado docker y docker-compose .","title":"1\ufe0f\u20e3 Instalaci\u00f3n de PostgreSQL con Docker"},{"location":"Docker_instrucciones/#11-crear-el-archivo-docker-composeyml","text":"En una carpeta llamada, por ejemplo, docker/postgres , crea un archivo con el siguiente contenido: version: '3.8' services: db: image: postgres:16.4 container_name: mi_postgres environment: POSTGRES_PASSWORD: postgres POSTGRES_USER: postgres POSTGRES_DB: geo volumes: - db_data:/var/lib/postgresql/data ports: - \"5432:5432\" volumes: db_data:","title":"1.1. Crear el archivo docker-compose.yml"},{"location":"Docker_instrucciones/#12-levantar-el-servicio","text":"Posici\u00f3nate en el terminal en el directorio donde est\u00e1 el fichero docker-compose.yml y ejecuta: docker-compose up -d","title":"1.2. Levantar el servicio"},{"location":"Docker_instrucciones/#13-verificar-el-contenedor","text":"Para comprobar que PostgreSQL est\u00e1 activo, ejecuta en el terminal: docker ps El resultado debe mostrar una entrada similar a la siguiente: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 327fd50443a7 postgres:8 \"docker-entrypoint.s\u2026\" 29 hours ago Up 6 hours 0.0.0.0:5432->5432/tcp docker_postgres Si aparece el contenedor mi_postgres con estado Up, significa que el servicio de PostgreSQL est\u00e1 funcionando correctamente.","title":"1.3. Verificar el contenedor"},{"location":"Docker_instrucciones/#2-conexion-de-postgresql-con-dbeaver","text":"Una vez el contenedor de PostgreSQL est\u00e1 activo, podemos conectarnos mediante el cliente gr\u00e1fico DBeaver .","title":"2\ufe0f\u20e3 Conexi\u00f3n de PostgreSQL con DBeaver"},{"location":"Docker_instrucciones/#21-crear-nueva-conexion","text":"Abre DBeaver . Selecciona Nueva conexi\u00f3n \u2192 PostgreSQL . Introduce los siguientes datos de conexi\u00f3n: Campo Valor Nombre de conexi\u00f3n docker-geo Server host localhost Port 5432 Database geo User name postgres Password postgres Haz clic en Test Connection para comprobar la conexi\u00f3n. Si la prueba es satisfactoria, guarda la conexi\u00f3n.","title":"2.1. Crear nueva conexi\u00f3n"},{"location":"Docker_instrucciones/#3-creacion-de-la-base-de-datos-geo","text":"En la conexi\u00f3n local de PostgreSQL (ya desde DBeaver o cualquier cliente SQL), ejecuta los siguientes scripts para crear las tablas del esquema public .","title":"3\ufe0f\u20e3 Creaci\u00f3n de la base de datos geo"},{"location":"Docker_instrucciones/#31-creacion-de-la-tabla-comarca","text":"CREATE TABLE public.comarca ( nom_c varchar(50) NOT NULL, provincia varchar(25) NULL, CONSTRAINT cp_com PRIMARY KEY (nom_c) );","title":"3.1. Creaci\u00f3n de la tabla COMARCA"},{"location":"Docker_instrucciones/#32-creacion-de-la-tabla-poblacio","text":"CREATE TABLE public.poblacio ( cod_m numeric(5) NOT NULL, nom varchar(50) NOT NULL, poblacio numeric(6) NULL, extensio numeric(6, 2) NULL, altura numeric(4) NULL, longitud varchar(50) NULL, latitud varchar(50) NULL, llengua bpchar(1) NULL, nom_c varchar(50) NULL, CONSTRAINT cp_pobl PRIMARY KEY (cod_m), CONSTRAINT ce_pob_com FOREIGN KEY (nom_c) REFERENCES public.comarca(nom_c) ON UPDATE CASCADE );","title":"3.2. Creaci\u00f3n de la tabla POBLACIO"},{"location":"Docker_instrucciones/#33-creacion-de-la-tabla-institut","text":"CREATE TABLE public.institut ( codi varchar(8) NOT NULL, nom varchar(60) NULL, adreca varchar(100) NULL, numero varchar(5) NULL, codpostal numeric(5) NULL, cod_m numeric(5) NULL, CONSTRAINT cp_ins PRIMARY KEY (codi), CONSTRAINT ce_ins_pob FOREIGN KEY (cod_m) REFERENCES public.poblacio(cod_m) );","title":"3.3. Creaci\u00f3n de la tabla INSTITUT"},{"location":"Docker_instrucciones/#4-carga-de-datos-iniciales","text":"Para completar la base de datos, ejecuta los siguientes scripts SQL desde DBeaver o desde el terminal de PostgreSQL . Cada script se encarga de insertar los datos de las tablas creadas previamente. \ud83d\udcc2 Inserci\u00f3n de comarcas \ud83d\udcc2 Inserci\u00f3n de poblacio \ud83d\udcc2 Inserci\u00f3n de insitut","title":"4\ufe0f\u20e3 Carga de datos iniciales"},{"location":"Ejercicio/","text":"\ud83d\udcdd Ejercicio: Operaciones sobre tu propia base de datos relacional en SQLite \u00b6 \ud83d\udccb Enunciado \u00b6 Dise\u00f1ar, crear y utilizar una base de datos relacional SQLite con al menos tres tablas relacionadas , aplicando los principios b\u00e1sicos del modelo relacional y desarrollando un programa Kotlin que permita realizar operaciones de acceso a datos de forma segura y estructurada. \ud83d\udee0\ufe0f Requisitos \u00b6 1. Base de datos \u00b6 Debes crear una base de datos de tem\u00e1tica libre (m\u00fasica, libros, cine, videojuegos, recetas, viajes, etc.). Incluye una imagen del modelo E/R de tu Base de datos: imagenER.png La base de datos debe contener: Al menos 3 tablas relacionadas. Claves primarias y claves for\u00e1neas correctamente definidas . Relaci\u00f3n de tipo 1:N o N:M. Poblar la BD con al menos 3 registros 2. Operaciones en Kotlin \u00b6 Desde un programa Kotlin con conexi\u00f3n JDBC a la base de datos SQLite: Crear operaciones CRUD (Crear, Leer, Actualizar, Eliminar) en al menos 2 tablas. Utiliza PrepareStatement para todas las consultas. Muestra los resultados por consola de forma clara y legible. Toda la funcionalidad debe estar implementada en un solo fichero main.kt , aunque tengas que estructurar el progrma en varias funciones. 3. Transacci\u00f3n \u00b6 Implementa una transacci\u00f3n que afecte a dos tablas relacionadas (por ejemplo, insertar un pedido y sus l\u00edneas, o una factura y sus productos). Debe usarse commit() y rollback() seg\u00fan corresponda. 4. Control de errores \u00b6 Implementa un sistema b\u00e1sico de manejo de errores ( try/catch ) que: Muestra un mensaje claro en caso de fallo. Cancela las operaciones si hay errores en la transacci\u00f3n ( rollback() ). No permita que la base de datos quede en un estado inconsistente. 5. Documentaci\u00f3n del c\u00f3digo \u00b6 El c\u00f3digo Kotlin debe incluir comentarios explicativos que: Indiquen claramente qu\u00e9 hace cada funci\u00f3n. Expliquen las partes principales del c\u00f3digo (conexi\u00f3n, inserci\u00f3n, consultas, transacci\u00f3n, etc.). Ayuden a entender la l\u00f3gica de negocio implementada. \ud83d\udce6 Estructura m\u00ednima del proyecto \u00b6 tu-tema-kotlin/ \u251c\u2500\u2500 resources/ \u2502 \u2514\u2500\u2500 tu_basededatos.sqlite \u2502 \u2514\u2500\u2500 imagenER.png \u2514\u2500\u2500 src/ \u2514\u2500\u2500 main/ \u2514\u2500\u2500 kotlin/ \u2514\u2500\u2500 tu_paquete/ \u2514\u2500\u2500 Main.kt \ud83d\udce9 Entrega \u00b6 Sube un archivo .zip con: La base de datos tu_basededatos.sqlite . El proyecto Kotlin con todas las operaciones implementadas en un solo fichero main.kt. \u2705 R\u00fabrica de evaluaci\u00f3n \u00b6 Criterio Puntos BD correctamente estructurada (m\u00edn. 3 tablas) 2 CRUD funcional en al menos dos tablas 3 Transacci\u00f3n bien implementada 2 C\u00f3digo estructurado, legible y sin errores 1 Documentaci\u00f3n del c\u00f3digo 2 Total 10","title":"\ud83d\udcdd Ejercicio obligatorio"},{"location":"Ejercicio/#ejercicio-operaciones-sobre-tu-propia-base-de-datos-relacional-en-sqlite","text":"","title":"\ud83d\udcdd Ejercicio: Operaciones sobre tu propia base de datos relacional en SQLite"},{"location":"Ejercicio/#enunciado","text":"Dise\u00f1ar, crear y utilizar una base de datos relacional SQLite con al menos tres tablas relacionadas , aplicando los principios b\u00e1sicos del modelo relacional y desarrollando un programa Kotlin que permita realizar operaciones de acceso a datos de forma segura y estructurada.","title":"\ud83d\udccb Enunciado"},{"location":"Ejercicio/#requisitos","text":"","title":"\ud83d\udee0\ufe0f Requisitos"},{"location":"Ejercicio/#1-base-de-datos","text":"Debes crear una base de datos de tem\u00e1tica libre (m\u00fasica, libros, cine, videojuegos, recetas, viajes, etc.). Incluye una imagen del modelo E/R de tu Base de datos: imagenER.png La base de datos debe contener: Al menos 3 tablas relacionadas. Claves primarias y claves for\u00e1neas correctamente definidas . Relaci\u00f3n de tipo 1:N o N:M. Poblar la BD con al menos 3 registros","title":"1. Base de datos"},{"location":"Ejercicio/#2-operaciones-en-kotlin","text":"Desde un programa Kotlin con conexi\u00f3n JDBC a la base de datos SQLite: Crear operaciones CRUD (Crear, Leer, Actualizar, Eliminar) en al menos 2 tablas. Utiliza PrepareStatement para todas las consultas. Muestra los resultados por consola de forma clara y legible. Toda la funcionalidad debe estar implementada en un solo fichero main.kt , aunque tengas que estructurar el progrma en varias funciones.","title":"2. Operaciones en Kotlin"},{"location":"Ejercicio/#3-transaccion","text":"Implementa una transacci\u00f3n que afecte a dos tablas relacionadas (por ejemplo, insertar un pedido y sus l\u00edneas, o una factura y sus productos). Debe usarse commit() y rollback() seg\u00fan corresponda.","title":"3. Transacci\u00f3n"},{"location":"Ejercicio/#4-control-de-errores","text":"Implementa un sistema b\u00e1sico de manejo de errores ( try/catch ) que: Muestra un mensaje claro en caso de fallo. Cancela las operaciones si hay errores en la transacci\u00f3n ( rollback() ). No permita que la base de datos quede en un estado inconsistente.","title":"4. Control de errores"},{"location":"Ejercicio/#5-documentacion-del-codigo","text":"El c\u00f3digo Kotlin debe incluir comentarios explicativos que: Indiquen claramente qu\u00e9 hace cada funci\u00f3n. Expliquen las partes principales del c\u00f3digo (conexi\u00f3n, inserci\u00f3n, consultas, transacci\u00f3n, etc.). Ayuden a entender la l\u00f3gica de negocio implementada.","title":"5. Documentaci\u00f3n del c\u00f3digo"},{"location":"Ejercicio/#estructura-minima-del-proyecto","text":"tu-tema-kotlin/ \u251c\u2500\u2500 resources/ \u2502 \u2514\u2500\u2500 tu_basededatos.sqlite \u2502 \u2514\u2500\u2500 imagenER.png \u2514\u2500\u2500 src/ \u2514\u2500\u2500 main/ \u2514\u2500\u2500 kotlin/ \u2514\u2500\u2500 tu_paquete/ \u2514\u2500\u2500 Main.kt","title":"\ud83d\udce6 Estructura m\u00ednima del proyecto"},{"location":"Ejercicio/#entrega","text":"Sube un archivo .zip con: La base de datos tu_basededatos.sqlite . El proyecto Kotlin con todas las operaciones implementadas en un solo fichero main.kt.","title":"\ud83d\udce9 Entrega"},{"location":"Ejercicio/#rubrica-de-evaluacion","text":"Criterio Puntos BD correctamente estructurada (m\u00edn. 3 tablas) 2 CRUD funcional en al menos dos tablas 3 Transacci\u00f3n bien implementada 2 C\u00f3digo estructurado, legible y sin errores 1 Documentaci\u00f3n del c\u00f3digo 2 Total 10","title":"\u2705 R\u00fabrica de evaluaci\u00f3n"},{"location":"Ejercicio_old/","text":"\ud83d\udcd8 Gu\u00eda para entregar una BD PostgreSQL como imagen Docker \u00b6 Requisitos \u00b6 Tener Docker instalado (Desktop o Engine). Conocer/usar la misma versi\u00f3n de PostgreSQL que usaste en tu proyecto (ej.: postgres:16 ). Disponer de tu dump : dump.sql (texto plano) o backup.dump (formato personalizado de pg_dump -Fc ). Consejo : Anota en tu entrega la versi\u00f3n exacta de PostgreSQL que has usado (por ejemplo, 14/15/16). 1) Crear y arrancar un contenedor limpio de PostgreSQL \u00b6 Levanta un contenedor con Postgres (ajusta la versi\u00f3n si no usas la 16): docker run -d --name pg_proyecto -e POSTGRES_PASSWORD=postgres -e POSTGRES_DB=proyecto_db -p 5432:5432 postgres:16 Datos por defecto del ejemplo: - Usuario: postgres - Contrase\u00f1a: postgres - Base de datos: proyecto_db - Puerto: 5432 2) Importar la BD del proyecto \u00b6 Opci\u00f3n A \u2014 Tienes dump.sql \u00b6 docker cp dump.sql pg_proyecto:/tmp/dump.sql docker exec -u postgres pg_proyecto psql -U postgres -d proyecto_db -f /tmp/dump.sql Opci\u00f3n B \u2014 Tienes backup.dump (formato pg_dump -Fc ) \u00b6 docker cp backup.dump pg_proyecto:/tmp/backup.dump docker exec -u postgres pg_proyecto createdb -U postgres proyecto_db docker exec -u postgres pg_proyecto pg_restore -U postgres -d proyecto_db -1 /tmp/backup.dump Verificaci\u00f3n r\u00e1pida \u00b6 docker exec -it pg_proyecto psql -U postgres -d proyecto_db -c \"\\dt\" Si ves tus tablas listadas, la importaci\u00f3n se ha realizado correctamente \u2705. 3) Congelar el contenedor en una imagen (con los datos dentro) \u00b6 Det\u00e9n el contenedor y cr\u00e9ale una imagen \u201ccongelada\u201d: docker stop pg_proyecto docker commit pg_proyecto alumno_postgres:1.0 Esto crea la imagen alumno_postgres:1.0 con tu BD ya cargada. 4) Exportar la imagen para entregarla \u00b6 Genera un fichero .tar de la imagen para compartirlo: docker save -o alumno_postgres_1_0.tar alumno_postgres:1.0 Entrega ese archivo ( alumno_postgres_1_0.tar ) a tu profesor/a (USB, nube, etc.). 5) C\u00f3mo lo probar\u00e1 el profesor \u00b6 Con el archivo .tar recibido, el profesor har\u00e1: docker load -i alumno_postgres_1_0.tar docker run -d --name pg_alumno -p 5433:5432 alumno_postgres:1.0 Y podr\u00e1 conectarse con DBeaver/pgAdmin/psql usando: - Host : localhost - Puerto : 5433 - Usuario : postgres - Contrase\u00f1a : postgres - Base de datos : proyecto_db 6) Plantilla de README para entregar junto con la imagen \u00b6 Copia/pega este README en tu proyecto (ajusta lo que proceda): Proyecto BD Alumno \u2014 Entrega Docker (Opci\u00f3n A) \u00b6 Datos de acceso - Versi\u00f3n PostgreSQL: 16 - Usuario: postgres - Contrase\u00f1a: postgres - Base de datos: proyecto_db - Puerto recomendado para pruebas del profesor: 5433 Instrucciones de ejecuci\u00f3n 1. Cargar la imagen: bash docker load -i alumno_postgres_1_0.tar Arrancar un contenedor para pruebas: bash docker run -d --name pg_alumno -p 5433:5432 alumno_postgres:1.0 Verificaci\u00f3n r\u00e1pida (tablas): bash docker exec -it pg_alumno psql -U postgres -d proyecto_db -c \"\\dt\" Notas - La imagen se ha creado con postgres:16 . Si necesita otra versi\u00f3n, ind\u00edquelo. - Si su sistema ya usa el puerto 5433 , cambie el mapeo a otro puerto libre (por ejemplo, -p 5434:5432 ). 7) Problemas comunes (y soluciones r\u00e1pidas) \u00b6 \u201cEl puerto ya est\u00e1 en uso\u201d \u2192 Cambia el puerto publicado (ej.: -p 5434:5432 ). Versi\u00f3n incompatible \u2192 Usa la misma postgres:<versi\u00f3n> que se us\u00f3 para generar la imagen/dump. No aparecen tablas tras importar \u2192 Revisa si importaste en la BD correcta ( -d proyecto_db ) y si el dump crea su propia BD (importa entonces contra -d postgres ). Extensiones faltantes \u2192 A\u00f1ade CREATE EXTENSION IF NOT EXISTS ...; tras importar, si tu proyecto las requiere. \u00a1Listo! Tu imagen contiene la BD y el profesor podr\u00e1 arrancarla y probarla sin restauraciones adicionales. \ud83d\udcd8 Gu\u00eda pr\u00e1ctica: Crear tu propia base de datos PostgreSQL en Supabase \u00b6 \ud83c\udfaf Objetivo \u00b6 En esta pr\u00e1ctica vas a crear tu propia base de datos en la nube usando Supabase . De esta forma podr\u00e1s trabajar con PostgreSQL sin instalar nada en tu ordenador, y la profesora podr\u00e1 revisar tu trabajo conect\u00e1ndose a tu BD. \ud83d\udd39 Paso 1 \u2013 Crear cuenta en Supabase \u00b6 Entra en \ud83d\udc49 https://supabase.com . Pulsa en Start your project . Reg\u00edstrate con GitHub (recomendado) o con tu correo electr\u00f3nico. \ud83d\udd39 Paso 2 \u2013 Crear un nuevo proyecto \u00b6 Pulsa en New project . Rellena los datos: Project name : pon tu nombre o usuario \u2192 ejemplo: geo_ad_alicia . Database password : inventa una contrase\u00f1a y gu\u00e1rdala (la necesitar\u00e1s). Region : elige Frankfurt (la m\u00e1s cercana). Pulsa Create new project y espera unos segundos. \ud83d\udd39 Paso 3 \u2013 Obtener la conexi\u00f3n a la base de datos \u00b6 En el panel de tu proyecto, entra en: Settings \u2192 Database \u2192 Connection Info . Copia estos datos (ap\u00fantalos aqu\u00ed): Host: ___________________________ Port: 5432 Database: postgres User: postgres Password: _______________________ Para conectarte desde Kotlin/JDBC usar\u00e1s algo as\u00ed: val url = \"jdbc:postgresql://<host>:5432/postgres\" val user = \"postgres\" val password = \"<tu_clave>\" \ud83d\udcf8 (Captura sugerida: pantalla con connection string en Supabase) \ud83d\udd39 Paso 4 \u2013 Crear tablas con el editor SQL \u00b6 En el men\u00fa lateral, entra en SQL Editor. Crea tus tablas con sentencias SQL. Inserta algunos datos de prueba con INSERT INTO. \ud83d\udcf8 (Captura sugerida: editor SQL con sentencias ejecutadas) \ud83d\udd39 Paso 5 \u2013 Conectarte desde DBeaver o IntelliJ \u00b6 Abre DBeaver o IntelliJ Database Tool. Crea una nueva conexi\u00f3n PostgreSQL. Introduce los datos que guardaste en el Paso 3. Comprueba que aparecen tus tablas. \ud83d\udcf8 (Captura sugerida: conexi\u00f3n en DBeaver mostrando tablas) \ud83d\udd39 Paso 6 \u2013 Compartir tu BD con la profesora \u00b6 Una vez creadas tus tablas, env\u00edame estos datos: Host Usuario (postgres) Password Nombre del proyecto (Puedes mandarlo por mensaje privado en Aules.) Yo podr\u00e9 entrar en tu BD y comprobar que has creado las tablas y los datos correctamente. \u2705","title":"Ejercicio old"},{"location":"Ejercicio_old/#guia-para-entregar-una-bd-postgresql-como-imagen-docker","text":"","title":"\ud83d\udcd8 Gu\u00eda para entregar una BD PostgreSQL como imagen Docker"},{"location":"Ejercicio_old/#requisitos","text":"Tener Docker instalado (Desktop o Engine). Conocer/usar la misma versi\u00f3n de PostgreSQL que usaste en tu proyecto (ej.: postgres:16 ). Disponer de tu dump : dump.sql (texto plano) o backup.dump (formato personalizado de pg_dump -Fc ). Consejo : Anota en tu entrega la versi\u00f3n exacta de PostgreSQL que has usado (por ejemplo, 14/15/16).","title":"Requisitos"},{"location":"Ejercicio_old/#1-crear-y-arrancar-un-contenedor-limpio-de-postgresql","text":"Levanta un contenedor con Postgres (ajusta la versi\u00f3n si no usas la 16): docker run -d --name pg_proyecto -e POSTGRES_PASSWORD=postgres -e POSTGRES_DB=proyecto_db -p 5432:5432 postgres:16 Datos por defecto del ejemplo: - Usuario: postgres - Contrase\u00f1a: postgres - Base de datos: proyecto_db - Puerto: 5432","title":"1) Crear y arrancar un contenedor limpio de PostgreSQL"},{"location":"Ejercicio_old/#2-importar-la-bd-del-proyecto","text":"","title":"2) Importar la BD del proyecto"},{"location":"Ejercicio_old/#opcion-a-tienes-dumpsql","text":"docker cp dump.sql pg_proyecto:/tmp/dump.sql docker exec -u postgres pg_proyecto psql -U postgres -d proyecto_db -f /tmp/dump.sql","title":"Opci\u00f3n A \u2014 Tienes dump.sql"},{"location":"Ejercicio_old/#opcion-b-tienes-backupdump-formato-pg_dump-fc","text":"docker cp backup.dump pg_proyecto:/tmp/backup.dump docker exec -u postgres pg_proyecto createdb -U postgres proyecto_db docker exec -u postgres pg_proyecto pg_restore -U postgres -d proyecto_db -1 /tmp/backup.dump","title":"Opci\u00f3n B \u2014 Tienes backup.dump (formato pg_dump -Fc)"},{"location":"Ejercicio_old/#verificacion-rapida","text":"docker exec -it pg_proyecto psql -U postgres -d proyecto_db -c \"\\dt\" Si ves tus tablas listadas, la importaci\u00f3n se ha realizado correctamente \u2705.","title":"Verificaci\u00f3n r\u00e1pida"},{"location":"Ejercicio_old/#3-congelar-el-contenedor-en-una-imagen-con-los-datos-dentro","text":"Det\u00e9n el contenedor y cr\u00e9ale una imagen \u201ccongelada\u201d: docker stop pg_proyecto docker commit pg_proyecto alumno_postgres:1.0 Esto crea la imagen alumno_postgres:1.0 con tu BD ya cargada.","title":"3) Congelar el contenedor en una imagen (con los datos dentro)"},{"location":"Ejercicio_old/#4-exportar-la-imagen-para-entregarla","text":"Genera un fichero .tar de la imagen para compartirlo: docker save -o alumno_postgres_1_0.tar alumno_postgres:1.0 Entrega ese archivo ( alumno_postgres_1_0.tar ) a tu profesor/a (USB, nube, etc.).","title":"4) Exportar la imagen para entregarla"},{"location":"Ejercicio_old/#5-como-lo-probara-el-profesor","text":"Con el archivo .tar recibido, el profesor har\u00e1: docker load -i alumno_postgres_1_0.tar docker run -d --name pg_alumno -p 5433:5432 alumno_postgres:1.0 Y podr\u00e1 conectarse con DBeaver/pgAdmin/psql usando: - Host : localhost - Puerto : 5433 - Usuario : postgres - Contrase\u00f1a : postgres - Base de datos : proyecto_db","title":"5) C\u00f3mo lo probar\u00e1 el profesor"},{"location":"Ejercicio_old/#6-plantilla-de-readme-para-entregar-junto-con-la-imagen","text":"Copia/pega este README en tu proyecto (ajusta lo que proceda):","title":"6) Plantilla de README para entregar junto con la imagen"},{"location":"Ejercicio_old/#proyecto-bd-alumno-entrega-docker-opcion-a","text":"Datos de acceso - Versi\u00f3n PostgreSQL: 16 - Usuario: postgres - Contrase\u00f1a: postgres - Base de datos: proyecto_db - Puerto recomendado para pruebas del profesor: 5433 Instrucciones de ejecuci\u00f3n 1. Cargar la imagen: bash docker load -i alumno_postgres_1_0.tar Arrancar un contenedor para pruebas: bash docker run -d --name pg_alumno -p 5433:5432 alumno_postgres:1.0 Verificaci\u00f3n r\u00e1pida (tablas): bash docker exec -it pg_alumno psql -U postgres -d proyecto_db -c \"\\dt\" Notas - La imagen se ha creado con postgres:16 . Si necesita otra versi\u00f3n, ind\u00edquelo. - Si su sistema ya usa el puerto 5433 , cambie el mapeo a otro puerto libre (por ejemplo, -p 5434:5432 ).","title":"Proyecto BD Alumno \u2014 Entrega Docker (Opci\u00f3n A)"},{"location":"Ejercicio_old/#7-problemas-comunes-y-soluciones-rapidas","text":"\u201cEl puerto ya est\u00e1 en uso\u201d \u2192 Cambia el puerto publicado (ej.: -p 5434:5432 ). Versi\u00f3n incompatible \u2192 Usa la misma postgres:<versi\u00f3n> que se us\u00f3 para generar la imagen/dump. No aparecen tablas tras importar \u2192 Revisa si importaste en la BD correcta ( -d proyecto_db ) y si el dump crea su propia BD (importa entonces contra -d postgres ). Extensiones faltantes \u2192 A\u00f1ade CREATE EXTENSION IF NOT EXISTS ...; tras importar, si tu proyecto las requiere. \u00a1Listo! Tu imagen contiene la BD y el profesor podr\u00e1 arrancarla y probarla sin restauraciones adicionales.","title":"7) Problemas comunes (y soluciones r\u00e1pidas)"},{"location":"Ejercicio_old/#guia-practica-crear-tu-propia-base-de-datos-postgresql-en-supabase","text":"","title":"\ud83d\udcd8 Gu\u00eda pr\u00e1ctica: Crear tu propia base de datos PostgreSQL en Supabase"},{"location":"Ejercicio_old/#objetivo","text":"En esta pr\u00e1ctica vas a crear tu propia base de datos en la nube usando Supabase . De esta forma podr\u00e1s trabajar con PostgreSQL sin instalar nada en tu ordenador, y la profesora podr\u00e1 revisar tu trabajo conect\u00e1ndose a tu BD.","title":"\ud83c\udfaf Objetivo"},{"location":"Ejercicio_old/#paso-1-crear-cuenta-en-supabase","text":"Entra en \ud83d\udc49 https://supabase.com . Pulsa en Start your project . Reg\u00edstrate con GitHub (recomendado) o con tu correo electr\u00f3nico.","title":"\ud83d\udd39 Paso 1 \u2013 Crear cuenta en Supabase"},{"location":"Ejercicio_old/#paso-2-crear-un-nuevo-proyecto","text":"Pulsa en New project . Rellena los datos: Project name : pon tu nombre o usuario \u2192 ejemplo: geo_ad_alicia . Database password : inventa una contrase\u00f1a y gu\u00e1rdala (la necesitar\u00e1s). Region : elige Frankfurt (la m\u00e1s cercana). Pulsa Create new project y espera unos segundos.","title":"\ud83d\udd39 Paso 2 \u2013 Crear un nuevo proyecto"},{"location":"Ejercicio_old/#paso-3-obtener-la-conexion-a-la-base-de-datos","text":"En el panel de tu proyecto, entra en: Settings \u2192 Database \u2192 Connection Info . Copia estos datos (ap\u00fantalos aqu\u00ed): Host: ___________________________ Port: 5432 Database: postgres User: postgres Password: _______________________ Para conectarte desde Kotlin/JDBC usar\u00e1s algo as\u00ed: val url = \"jdbc:postgresql://<host>:5432/postgres\" val user = \"postgres\" val password = \"<tu_clave>\" \ud83d\udcf8 (Captura sugerida: pantalla con connection string en Supabase)","title":"\ud83d\udd39 Paso 3 \u2013 Obtener la conexi\u00f3n a la base de datos"},{"location":"Ejercicio_old/#paso-4-crear-tablas-con-el-editor-sql","text":"En el men\u00fa lateral, entra en SQL Editor. Crea tus tablas con sentencias SQL. Inserta algunos datos de prueba con INSERT INTO. \ud83d\udcf8 (Captura sugerida: editor SQL con sentencias ejecutadas)","title":"\ud83d\udd39 Paso 4 \u2013 Crear tablas con el editor SQL"},{"location":"Ejercicio_old/#paso-5-conectarte-desde-dbeaver-o-intellij","text":"Abre DBeaver o IntelliJ Database Tool. Crea una nueva conexi\u00f3n PostgreSQL. Introduce los datos que guardaste en el Paso 3. Comprueba que aparecen tus tablas. \ud83d\udcf8 (Captura sugerida: conexi\u00f3n en DBeaver mostrando tablas)","title":"\ud83d\udd39 Paso 5 \u2013 Conectarte desde DBeaver o IntelliJ"},{"location":"Ejercicio_old/#paso-6-compartir-tu-bd-con-la-profesora","text":"Una vez creadas tus tablas, env\u00edame estos datos: Host Usuario (postgres) Password Nombre del proyecto (Puedes mandarlo por mensaje privado en Aules.) Yo podr\u00e9 entrar en tu BD y comprobar que has creado las tablas y los datos correctamente. \u2705","title":"\ud83d\udd39 Paso 6 \u2013 Compartir tu BD con la profesora"},{"location":"Estructura/","text":"Ejemplo completo en PostgreSQL \u00b6 El esquema l\u00f3gico y relacional de la BD a la que nos vamos a conectar es el siguiente: Esta BD se encuentra en un servidor remoto y es accesible desde cualquier lugar, solo necesitamos saber sus datos de conexi\u00f3n. La BD tambi\u00e9n la vamos a replicar en un contenedor docker para tener ambas opciones y poder trabajar tanto en local como en remoto. Datos de conexi\u00f3n al servido remoto Servidor (host) : 89.36.214.106 Port : 5432 (\u00e9s el port per defecte) Usuari : geo_ad Contrasenya : geo_ad Base de dades : geo_ad Intrucciones para replicar la BD en local (Docker) Las instrucciones para crear la base de datos en docker las pod\u00e9is encontrar en el siguiente enlace: Instrucciones Configuraci\u00f3n de Dependencias (Gradle) Lo primero ser\u00e1 incluir las dependencia necesarias en build.gradle.kts // build.gradle.kts (para PostgreSQL) dependencies { implementation(\"org.postgresql:postgresql:42.6.0\") } Conexi\u00f3n a un servidor Postgres remoto Ejemplo_conexion_Postgres_remota.kt import java.sql.DriverManager object DatabaseRemota { private const val URL = \"jdbc:postgresql://89.36.214.106:5432/geo_ad\" private const val USER = \"geo_ad\" private const val PASSWORD = \"geo_ad\" fun getConnection() = DriverManager.getConnection(URL, USER, PASSWORD) } Postgress en Docker Ejemplo_conexion_Postgres_local.kt import java.sql.DriverManager object DatabaseLocal { private const val URL = \"jdbc:postgresql://localhost:5432/geo\" private const val USER = \"postgres\" private const val PASSWORD = \"postgres\" fun getConnection() = DriverManager.getConnection(URL, USER, PASSWORD) } Operaciones CRUD Los ejemplos siguientes son igualmente v\u00e1lidos tanto si nos conectamos al servidor remoto como al local, ya que son iguales. Una vez conectados a la BD, ya podemos hacer operaciones CRUD sobre ella, utilizando el objeto de conexi\u00f3n correspondiente. Read (SELECT) Ejemplo_Select.kt fun main(args: Array<String>) { val sql = \"SELECT * FROM institut\" DatabaseLocal.getConnection().use { conn -> // DatabaseRemota si se conecta al servidor del instituto conn.prepareStatement(sql).use { stmt -> stmt.executeQuery().use { rs -> while (rs.next()) { print(\"\" + rs.getString(1) + \"\\t\") println(rs.getString(2)) } } } } } Create (INSERT) El siguiente ejemplo inserta un istituto de prueba. Ejemplo_Insert.kt fun main(args: Array<String>) { val sql =\"INSERT INTO institut (codi,nom,adreca,numero,codpostal,cod_m) VALUES(?,?,?,?,?,?)\" DatabaseLocal.getConnection().use { conn -> conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"00000000\") stmt.setString(2, \"IES PRUEBA\") stmt.setString(3, \"CASTELL\u00d3N\") stmt.setString(4, \"S/N\") stmt.setInt(5, 12560) stmt.setInt(6, 12040) stmt.executeUpdate() } } } Update (UPDATE) El siguiente ejemplo actualiza el campo nombre del instituto de prueba insertado. Ejemplo_Update.kt fun main() { val sql = \"UPDATE institut SET nom = ? WHERE codi = ?\" DatabaseLocal.getConnection().use { conn -> conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"IES PRUEBA 2\") stmt.setString(2, \"00000000\") stmt.executeUpdate() } } } Delete (DELETE) El siguiente ejemplo elimina el instituto de prueba insertado. Ejemplo_Delete.kt fun main() { val sql = \"DELETE FROM institut WHERE codi = ?\" DatabaseLocal.getConnection().use { conn -> conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"00000000\") stmt.executeUpdate() } } }","title":"Ejemplo completo en PostgreSQL"},{"location":"Estructura/#ejemplo-completo-en-postgresql","text":"El esquema l\u00f3gico y relacional de la BD a la que nos vamos a conectar es el siguiente: Esta BD se encuentra en un servidor remoto y es accesible desde cualquier lugar, solo necesitamos saber sus datos de conexi\u00f3n. La BD tambi\u00e9n la vamos a replicar en un contenedor docker para tener ambas opciones y poder trabajar tanto en local como en remoto. Datos de conexi\u00f3n al servido remoto Servidor (host) : 89.36.214.106 Port : 5432 (\u00e9s el port per defecte) Usuari : geo_ad Contrasenya : geo_ad Base de dades : geo_ad Intrucciones para replicar la BD en local (Docker) Las instrucciones para crear la base de datos en docker las pod\u00e9is encontrar en el siguiente enlace: Instrucciones Configuraci\u00f3n de Dependencias (Gradle) Lo primero ser\u00e1 incluir las dependencia necesarias en build.gradle.kts // build.gradle.kts (para PostgreSQL) dependencies { implementation(\"org.postgresql:postgresql:42.6.0\") } Conexi\u00f3n a un servidor Postgres remoto Ejemplo_conexion_Postgres_remota.kt import java.sql.DriverManager object DatabaseRemota { private const val URL = \"jdbc:postgresql://89.36.214.106:5432/geo_ad\" private const val USER = \"geo_ad\" private const val PASSWORD = \"geo_ad\" fun getConnection() = DriverManager.getConnection(URL, USER, PASSWORD) } Postgress en Docker Ejemplo_conexion_Postgres_local.kt import java.sql.DriverManager object DatabaseLocal { private const val URL = \"jdbc:postgresql://localhost:5432/geo\" private const val USER = \"postgres\" private const val PASSWORD = \"postgres\" fun getConnection() = DriverManager.getConnection(URL, USER, PASSWORD) } Operaciones CRUD Los ejemplos siguientes son igualmente v\u00e1lidos tanto si nos conectamos al servidor remoto como al local, ya que son iguales. Una vez conectados a la BD, ya podemos hacer operaciones CRUD sobre ella, utilizando el objeto de conexi\u00f3n correspondiente. Read (SELECT) Ejemplo_Select.kt fun main(args: Array<String>) { val sql = \"SELECT * FROM institut\" DatabaseLocal.getConnection().use { conn -> // DatabaseRemota si se conecta al servidor del instituto conn.prepareStatement(sql).use { stmt -> stmt.executeQuery().use { rs -> while (rs.next()) { print(\"\" + rs.getString(1) + \"\\t\") println(rs.getString(2)) } } } } } Create (INSERT) El siguiente ejemplo inserta un istituto de prueba. Ejemplo_Insert.kt fun main(args: Array<String>) { val sql =\"INSERT INTO institut (codi,nom,adreca,numero,codpostal,cod_m) VALUES(?,?,?,?,?,?)\" DatabaseLocal.getConnection().use { conn -> conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"00000000\") stmt.setString(2, \"IES PRUEBA\") stmt.setString(3, \"CASTELL\u00d3N\") stmt.setString(4, \"S/N\") stmt.setInt(5, 12560) stmt.setInt(6, 12040) stmt.executeUpdate() } } } Update (UPDATE) El siguiente ejemplo actualiza el campo nombre del instituto de prueba insertado. Ejemplo_Update.kt fun main() { val sql = \"UPDATE institut SET nom = ? WHERE codi = ?\" DatabaseLocal.getConnection().use { conn -> conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"IES PRUEBA 2\") stmt.setString(2, \"00000000\") stmt.executeUpdate() } } } Delete (DELETE) El siguiente ejemplo elimina el instituto de prueba insertado. Ejemplo_Delete.kt fun main() { val sql = \"DELETE FROM institut WHERE codi = ?\" DatabaseLocal.getConnection().use { conn -> conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"00000000\") stmt.executeUpdate() } } }","title":"Ejemplo completo en PostgreSQL"},{"location":"Examen/","text":"\ud83e\uddea Ejercicio: Gesti\u00f3n musical con SQLite y JDBC (sin DAO) \u00b6 \ud83c\udfaf Objetivo \u00b6 Desarrollar un programa en Kotlin que se conecte a una base de datos SQLite llamada musica.sqlite , ubicada en la carpeta resources , y realice las siguientes operaciones directamente desde main() , sin utilizar data class ni DAO. \ud83d\udcc1 Recursos proporcionados \u00b6 schema.sql : crea la base de datos con las tablas estilo , grupo , disco y cancion . insert.sql : inserta datos de ejemplo para probar. Archivo musica.sqlite ya creado (puedes generarlo desde los scripts). \ud83e\udde9 Requisitos del ejercicio \u00b6 Establecer conexi\u00f3n con la base de datos musica.sqlite desde Kotlin usando JDBC. Insertar un nuevo grupo musical con los siguientes datos: id : 99 nombre : Nach pa\u00eds : Espa\u00f1a a\u00f1o de creaci\u00f3n : 1999 estilo : 2 (Rap, ya existente en la tabla estilo ) Mostrar por pantalla todos los grupos actuales tras la inserci\u00f3n, incluyendo sus atributos. Iniciar una transacci\u00f3n JDBC que haga lo siguiente: Insertar un disco con: id : 20 t\u00edtulo : Un d\u00eda en el mundo a\u00f1o : 2008 grupo : 99 (el grupo insertado antes) Insertar dos canciones asociadas a ese disco: Copenhague (300 s) S\u00e1lvese quien pueda (270 s) Si todo va bien, confirmar la transacci\u00f3n ( commit ); en caso de error, revertirla ( rollback ). \ud83d\udee0 Instrucciones adicionales \u00b6 Toda la l\u00f3gica debe estar en el fichero Main.kt . No se debe utilizar ning\u00fan data class , DAO ni estructuras adicionales. Utiliza PreparedStatement para todas las consultas. El programa debe imprimir los resultados de forma legible. \u2705 Criterios de evaluaci\u00f3n \u00b6 Criterio Puntos Conexi\u00f3n correctamente establecida 1 Inserci\u00f3n del grupo 1 Listado de grupos 1 Uso correcto de transacciones 2 Inserci\u00f3n correcta de disco y canciones 2 Gesti\u00f3n de errores con rollback 2 C\u00f3digo estructurado y funcional 1 Total 10","title":"\ud83e\uddea Ejercicio: Gesti\u00f3n musical con SQLite y JDBC (sin DAO)"},{"location":"Examen/#ejercicio-gestion-musical-con-sqlite-y-jdbc-sin-dao","text":"","title":"\ud83e\uddea Ejercicio: Gesti\u00f3n musical con SQLite y JDBC (sin DAO)"},{"location":"Examen/#objetivo","text":"Desarrollar un programa en Kotlin que se conecte a una base de datos SQLite llamada musica.sqlite , ubicada en la carpeta resources , y realice las siguientes operaciones directamente desde main() , sin utilizar data class ni DAO.","title":"\ud83c\udfaf Objetivo"},{"location":"Examen/#recursos-proporcionados","text":"schema.sql : crea la base de datos con las tablas estilo , grupo , disco y cancion . insert.sql : inserta datos de ejemplo para probar. Archivo musica.sqlite ya creado (puedes generarlo desde los scripts).","title":"\ud83d\udcc1 Recursos proporcionados"},{"location":"Examen/#requisitos-del-ejercicio","text":"Establecer conexi\u00f3n con la base de datos musica.sqlite desde Kotlin usando JDBC. Insertar un nuevo grupo musical con los siguientes datos: id : 99 nombre : Nach pa\u00eds : Espa\u00f1a a\u00f1o de creaci\u00f3n : 1999 estilo : 2 (Rap, ya existente en la tabla estilo ) Mostrar por pantalla todos los grupos actuales tras la inserci\u00f3n, incluyendo sus atributos. Iniciar una transacci\u00f3n JDBC que haga lo siguiente: Insertar un disco con: id : 20 t\u00edtulo : Un d\u00eda en el mundo a\u00f1o : 2008 grupo : 99 (el grupo insertado antes) Insertar dos canciones asociadas a ese disco: Copenhague (300 s) S\u00e1lvese quien pueda (270 s) Si todo va bien, confirmar la transacci\u00f3n ( commit ); en caso de error, revertirla ( rollback ).","title":"\ud83e\udde9 Requisitos del ejercicio"},{"location":"Examen/#instrucciones-adicionales","text":"Toda la l\u00f3gica debe estar en el fichero Main.kt . No se debe utilizar ning\u00fan data class , DAO ni estructuras adicionales. Utiliza PreparedStatement para todas las consultas. El programa debe imprimir los resultados de forma legible.","title":"\ud83d\udee0 Instrucciones adicionales"},{"location":"Examen/#criterios-de-evaluacion","text":"Criterio Puntos Conexi\u00f3n correctamente establecida 1 Inserci\u00f3n del grupo 1 Listado de grupos 1 Uso correcto de transacciones 2 Inserci\u00f3n correcta de disco y canciones 2 Gesti\u00f3n de errores con rollback 2 C\u00f3digo estructurado y funcional 1 Total 10","title":"\u2705 Criterios de evaluaci\u00f3n"},{"location":"Introduccion/","text":"Introducci\u00f3n \u00b6 Aunque en el m\u00f3dulo de Bases de Datos de 1\u00ba de DAM ya se estudiaron en profundidad, conviene repasar brevemente algunos conceptos clave de las bases de datos relacionales, ya que en este m\u00f3dulo (Acceso a Datos) trabajaremos con ellas desde el c\u00f3digo. En este m\u00f3dulo no nos centraremos en dise\u00f1ar bases de datos (eso ya se vio), sino en conectarnos a ellas desde el c\u00f3digo, consultar datos, modificarlos y automatizar operaciones con funciones, procedimientos y transacciones. \ud83d\udd39BD Relacionales \u00b6 Una base de datos relacional (BDR) es un sistema de almacenamiento de informaci\u00f3n que organiza los datos en tablas compuestas por filas y columnas, donde cada fila representa un registro \u00fanico y cada columna contiene un atributo espec\u00edfico de ese registro. Estas BD siguen el Modelo Relacional , desarrollado por Edgar F. Codd en la d\u00e9cada de 1970, y permite establecer v\u00ednculos o relaciones entre diferentes tablas mediante claves primarias y for\u00e1neas , facilitando as\u00ed la integridad, la coherencia y la eficiencia en el manejo de grandes vol\u00famenes de datos. La principal ventaja de las bases de datos relacionales es su capacidad para estructurar la informaci\u00f3n de manera l\u00f3gica y accesible, permitiendo a los usuarios realizar consultas complejas, analizar relaciones entre distintos conjuntos de datos y mantener la precisi\u00f3n y seguridad de la informaci\u00f3n. Gracias al uso del lenguaje SQL (Structured Query Language), se pueden crear, modificar, consultar y eliminar datos de forma sencilla y estandarizada, lo que las convierte en la opci\u00f3n preferida para una amplia variedad de aplicaciones empresariales y tecnol\u00f3gicas. Las bases de datos relacionales (BDR) son esenciales en el desarrollo de aplicaciones modernas. Su integraci\u00f3n con una aplicaci\u00f3n requiere conectores que faciliten la comunicaci\u00f3n entre el lenguaje de programaci\u00f3n y el gestor de base de datos. Este tema se centra en c\u00f3mo realizar esa conexi\u00f3n, c\u00f3mo trabajar con datos mediante sentencias SQL y c\u00f3mo aplicar buenas pr\u00e1cticas, como el cierre de recursos, el uso de transacciones y procedimientos almacenados. Modelo Relacional (Una breve introducci\u00f3n) El modelo relacional es un tipo de modelo de datos que organiza la informaci\u00f3n en tablas (tambi\u00e9n llamadas relaciones), y es la base te\u00f3rica de las bases de datos relacionales. Cada tabla representa una entidad (por ejemplo, clientes, productos, facturas) y cada fila de la tabla representa un registro individual. Las tablas se pueden relacionar entre s\u00ed mediante claves, lo que permite una organizaci\u00f3n l\u00f3gica y eficiente de la informaci\u00f3n. Tablas Una tabla representa un conjunto de datos relacionados. Tiene: Filas (registros) : cada fila contiene un dato completo. Columnas (campos) : definen el tipo de informaci\u00f3n que contiene la tabla. Ejemplo de tabla clientes : id_cliente nombre ciudad 1 Luc\u00eda Valencia 2 Carlos Madrid Clave primaria (Primary Key) Es una columna (o conjunto de columnas) que identifica de forma \u00fanica cada fila de una tabla. Ejemplo: id_cliente es clave primaria en la tabla clientes . Clave for\u00e1nea (Foreign Key) Es una columna que hace referencia a una clave primaria de otra tabla para establecer una relaci\u00f3n. Ejemplo: en la tabla facturas , el campo id_cliente puede ser clave for\u00e1nea que apunta a clientes(id_cliente) . Lenguaje SQL El lenguaje SQL (Structured Query Language) se utiliza para gestionar bases de datos relacionales. Comandos b\u00e1sicos: SELECT : consultar datos INSERT : a\u00f1adir registros UPDATE : modificar datos existentes DELETE : eliminar registros CREATE : definir tablas, claves, relaciones, etc. Ejemplo sencillo de consulta: SELECT nombre FROM clientes WHERE ciudad = 'Valencia'; \ud83d\udd39Conectores VS ORM \u00b6 Cuando desarrollamos aplicaciones que trabajan con informaci\u00f3n persistente, necesitamos acceder a bases de datos relacionales para consultar, insertar, modificar o eliminar datos. Existen dos formas principales de hacerlo desde el c\u00f3digo: Acceso mediante conectores Acceso mediante ORM 1-. Acceso mediante conectores (JDBC - Java Database Connectivity) JDBC es una API est\u00e1ndar de Java (y compatible con Kotlin) que permite conectarse a una base de datos, enviar instrucciones SQL y procesar los resultados manualmente. Es el m\u00e9todo de m\u00e1s bajo nivel, pero ofrece un control total sobre lo que ocurre en la base de datos. Caracter\u00edsticas: El programador escribe directamente las consultas SQL. Requiere gestionar manualmente conexiones, sentencias y resultados. Se necesita un driver espec\u00edfico (conector) para el sistema gestor de bases de datos (SGBD) concreto: Algunos ejemplos de conectores SGBD Conector (Driver JDBC) URL de conexi\u00f3n t\u00edpica PostgreSQL org.postgresql.Driver jdbc:postgresql://host:puerto/basedatos MySQL / MariaDB com.mysql.cj.jdbc.Driver jdbc:mysql://host:puerto/basedatos SQLite (embebido) org.sqlite.JDBC jdbc:sqlite:ruta_al_fichero.db 2- Acceso mediante ORM (Object-Relational Mapping) Un ORM es una herramienta que permite trabajar con la base de datos como si fuera un conjunto de objetos, evitando tener que escribir directamente SQL. El ORM se encarga de mapear las tablas a clases y los registros a objetos, y traduce autom\u00e1ticamente las operaciones del c\u00f3digo a consultas SQL. Caracter\u00edsticas: Se trabaja con clases en lugar de tablas SQL. Ahorra mucho c\u00f3digo repetitivo. Ideal para proyectos medianos o grandes que requieren mantener muchas entidades. JPA (Java Persistence API) es una especificaci\u00f3n est\u00e1ndar de Java que define c\u00f3mo se deben mapear objetos Java (o Kotlin) a tablas de bases de datos relacionales. Es decir, permite gestionar la persistencia de datos de forma orientada a objetos, sin necesidad de escribir SQL directamente. Es el est\u00e1ndar utilizado por las herramientas ORM como Hibernate, EclipseLink, o Spring Data JPA. Algunos ejemplos de ORMs ORM / Framework Lenguaje Descripci\u00f3n Hibernate Java/Kotlin El ORM m\u00e1s utilizado con JPA Exposed Kotlin ORM ligero y expresivo creado por JetBrains Spring Data JPA Java/Kotlin Abstracci\u00f3n que automatiza el acceso a datos Room Java/Kotlin ORM oficial para bases de datos SQLite en Android Conclusi\u00f3n JDBC es ideal para aprender los fundamentos del acceso a datos y tener control total. ORM es ideal para trabajar de forma m\u00e1s productiva en aplicaciones complejas. Ambos m\u00e9todos son \u00fatiles y complementarios: aprender JDBC ayuda a entender mejor lo que hace un ORM por debajo. \ud83d\udd39Tipos de SGBD relacionales \u00b6 Conocer qu\u00e9 tipo de gestor de base de datos est\u00e1s utilizando es esencial para poder conectarte correctamente desde tu aplicaci\u00f3n, ya que cada uno necesita su propio conector o driver. No existe un \u00fanico tipo de sistema gestor de bases de datos (SGBD): existen varios, con caracter\u00edsticas y objetivos diferente: 1- Gestores independientes (cliente-servidor) PostgreSQL, MySQL, Oracle, SQL Server... Sistemas robustos y escalables, ideales para entornos multi-usuario y aplicaciones web. Requieren un servidor dedicado y una configuraci\u00f3n m\u00e1s compleja. Casos de uso: aplicaciones web, servicios empresariales, sistemas con alta demanda de acceso concurrente. 2- Gestores embebidos SQLite, H2, Derby... Base de datos ligera, sin servidor, ideal para aplicaciones m\u00f3viles o de escritorio donde no se requiere gesti\u00f3n centralizada. F\u00e1cil de configurar y desplegar, ya que la base de datos reside en un archivo local. Casos de uso: aplicaciones de escritorio, m\u00f3viles, prototipos, pruebas unitarias.","title":"\ud83d\udd39Introducci\u00f3n"},{"location":"Introduccion/#introduccion","text":"Aunque en el m\u00f3dulo de Bases de Datos de 1\u00ba de DAM ya se estudiaron en profundidad, conviene repasar brevemente algunos conceptos clave de las bases de datos relacionales, ya que en este m\u00f3dulo (Acceso a Datos) trabajaremos con ellas desde el c\u00f3digo. En este m\u00f3dulo no nos centraremos en dise\u00f1ar bases de datos (eso ya se vio), sino en conectarnos a ellas desde el c\u00f3digo, consultar datos, modificarlos y automatizar operaciones con funciones, procedimientos y transacciones.","title":"Introducci\u00f3n"},{"location":"Introduccion/#bd-relacionales","text":"Una base de datos relacional (BDR) es un sistema de almacenamiento de informaci\u00f3n que organiza los datos en tablas compuestas por filas y columnas, donde cada fila representa un registro \u00fanico y cada columna contiene un atributo espec\u00edfico de ese registro. Estas BD siguen el Modelo Relacional , desarrollado por Edgar F. Codd en la d\u00e9cada de 1970, y permite establecer v\u00ednculos o relaciones entre diferentes tablas mediante claves primarias y for\u00e1neas , facilitando as\u00ed la integridad, la coherencia y la eficiencia en el manejo de grandes vol\u00famenes de datos. La principal ventaja de las bases de datos relacionales es su capacidad para estructurar la informaci\u00f3n de manera l\u00f3gica y accesible, permitiendo a los usuarios realizar consultas complejas, analizar relaciones entre distintos conjuntos de datos y mantener la precisi\u00f3n y seguridad de la informaci\u00f3n. Gracias al uso del lenguaje SQL (Structured Query Language), se pueden crear, modificar, consultar y eliminar datos de forma sencilla y estandarizada, lo que las convierte en la opci\u00f3n preferida para una amplia variedad de aplicaciones empresariales y tecnol\u00f3gicas. Las bases de datos relacionales (BDR) son esenciales en el desarrollo de aplicaciones modernas. Su integraci\u00f3n con una aplicaci\u00f3n requiere conectores que faciliten la comunicaci\u00f3n entre el lenguaje de programaci\u00f3n y el gestor de base de datos. Este tema se centra en c\u00f3mo realizar esa conexi\u00f3n, c\u00f3mo trabajar con datos mediante sentencias SQL y c\u00f3mo aplicar buenas pr\u00e1cticas, como el cierre de recursos, el uso de transacciones y procedimientos almacenados. Modelo Relacional (Una breve introducci\u00f3n) El modelo relacional es un tipo de modelo de datos que organiza la informaci\u00f3n en tablas (tambi\u00e9n llamadas relaciones), y es la base te\u00f3rica de las bases de datos relacionales. Cada tabla representa una entidad (por ejemplo, clientes, productos, facturas) y cada fila de la tabla representa un registro individual. Las tablas se pueden relacionar entre s\u00ed mediante claves, lo que permite una organizaci\u00f3n l\u00f3gica y eficiente de la informaci\u00f3n. Tablas Una tabla representa un conjunto de datos relacionados. Tiene: Filas (registros) : cada fila contiene un dato completo. Columnas (campos) : definen el tipo de informaci\u00f3n que contiene la tabla. Ejemplo de tabla clientes : id_cliente nombre ciudad 1 Luc\u00eda Valencia 2 Carlos Madrid Clave primaria (Primary Key) Es una columna (o conjunto de columnas) que identifica de forma \u00fanica cada fila de una tabla. Ejemplo: id_cliente es clave primaria en la tabla clientes . Clave for\u00e1nea (Foreign Key) Es una columna que hace referencia a una clave primaria de otra tabla para establecer una relaci\u00f3n. Ejemplo: en la tabla facturas , el campo id_cliente puede ser clave for\u00e1nea que apunta a clientes(id_cliente) . Lenguaje SQL El lenguaje SQL (Structured Query Language) se utiliza para gestionar bases de datos relacionales. Comandos b\u00e1sicos: SELECT : consultar datos INSERT : a\u00f1adir registros UPDATE : modificar datos existentes DELETE : eliminar registros CREATE : definir tablas, claves, relaciones, etc. Ejemplo sencillo de consulta: SELECT nombre FROM clientes WHERE ciudad = 'Valencia';","title":"\ud83d\udd39BD Relacionales"},{"location":"Introduccion/#conectores-vs-orm","text":"Cuando desarrollamos aplicaciones que trabajan con informaci\u00f3n persistente, necesitamos acceder a bases de datos relacionales para consultar, insertar, modificar o eliminar datos. Existen dos formas principales de hacerlo desde el c\u00f3digo: Acceso mediante conectores Acceso mediante ORM 1-. Acceso mediante conectores (JDBC - Java Database Connectivity) JDBC es una API est\u00e1ndar de Java (y compatible con Kotlin) que permite conectarse a una base de datos, enviar instrucciones SQL y procesar los resultados manualmente. Es el m\u00e9todo de m\u00e1s bajo nivel, pero ofrece un control total sobre lo que ocurre en la base de datos. Caracter\u00edsticas: El programador escribe directamente las consultas SQL. Requiere gestionar manualmente conexiones, sentencias y resultados. Se necesita un driver espec\u00edfico (conector) para el sistema gestor de bases de datos (SGBD) concreto: Algunos ejemplos de conectores SGBD Conector (Driver JDBC) URL de conexi\u00f3n t\u00edpica PostgreSQL org.postgresql.Driver jdbc:postgresql://host:puerto/basedatos MySQL / MariaDB com.mysql.cj.jdbc.Driver jdbc:mysql://host:puerto/basedatos SQLite (embebido) org.sqlite.JDBC jdbc:sqlite:ruta_al_fichero.db 2- Acceso mediante ORM (Object-Relational Mapping) Un ORM es una herramienta que permite trabajar con la base de datos como si fuera un conjunto de objetos, evitando tener que escribir directamente SQL. El ORM se encarga de mapear las tablas a clases y los registros a objetos, y traduce autom\u00e1ticamente las operaciones del c\u00f3digo a consultas SQL. Caracter\u00edsticas: Se trabaja con clases en lugar de tablas SQL. Ahorra mucho c\u00f3digo repetitivo. Ideal para proyectos medianos o grandes que requieren mantener muchas entidades. JPA (Java Persistence API) es una especificaci\u00f3n est\u00e1ndar de Java que define c\u00f3mo se deben mapear objetos Java (o Kotlin) a tablas de bases de datos relacionales. Es decir, permite gestionar la persistencia de datos de forma orientada a objetos, sin necesidad de escribir SQL directamente. Es el est\u00e1ndar utilizado por las herramientas ORM como Hibernate, EclipseLink, o Spring Data JPA. Algunos ejemplos de ORMs ORM / Framework Lenguaje Descripci\u00f3n Hibernate Java/Kotlin El ORM m\u00e1s utilizado con JPA Exposed Kotlin ORM ligero y expresivo creado por JetBrains Spring Data JPA Java/Kotlin Abstracci\u00f3n que automatiza el acceso a datos Room Java/Kotlin ORM oficial para bases de datos SQLite en Android Conclusi\u00f3n JDBC es ideal para aprender los fundamentos del acceso a datos y tener control total. ORM es ideal para trabajar de forma m\u00e1s productiva en aplicaciones complejas. Ambos m\u00e9todos son \u00fatiles y complementarios: aprender JDBC ayuda a entender mejor lo que hace un ORM por debajo.","title":"\ud83d\udd39Conectores VS ORM"},{"location":"Introduccion/#tipos-de-sgbd-relacionales","text":"Conocer qu\u00e9 tipo de gestor de base de datos est\u00e1s utilizando es esencial para poder conectarte correctamente desde tu aplicaci\u00f3n, ya que cada uno necesita su propio conector o driver. No existe un \u00fanico tipo de sistema gestor de bases de datos (SGBD): existen varios, con caracter\u00edsticas y objetivos diferente: 1- Gestores independientes (cliente-servidor) PostgreSQL, MySQL, Oracle, SQL Server... Sistemas robustos y escalables, ideales para entornos multi-usuario y aplicaciones web. Requieren un servidor dedicado y una configuraci\u00f3n m\u00e1s compleja. Casos de uso: aplicaciones web, servicios empresariales, sistemas con alta demanda de acceso concurrente. 2- Gestores embebidos SQLite, H2, Derby... Base de datos ligera, sin servidor, ideal para aplicaciones m\u00f3viles o de escritorio donde no se requiere gesti\u00f3n centralizada. F\u00e1cil de configurar y desplegar, ya que la base de datos reside en un archivo local. Casos de uso: aplicaciones de escritorio, m\u00f3viles, prototipos, pruebas unitarias.","title":"\ud83d\udd39Tipos de SGBD relacionales"},{"location":"Operaciones/","text":"Operaciones sobre la BD \u00b6 En JDBC (Java Database Connectivity), las operaciones sobre la base de datos se realizan utilizando los siguientes objetos y m\u00e9todos: Connection , como ya se explic\u00f3 en el apartado anterior, establece el canal de comunicaci\u00f3n con el SGBD (PostgreSQL, MySQL, etc.) Los objetos PrepareStatement y CreateStatement se utlizan para enviar consultas SQL desde tu programa hacia la base de datos, pero se usan de forma distinta y tienen ventajas diferentes. ResultSet es un objeto que contiene el resultado de una consulta SQL, y permite recorrer fila a fila el conjunto de resultados, accediendo a cada campo por nombre o por posici\u00f3n. Los m\u00e9todos executeQuery() y executeUpdate() se utilizan para ejecutar sentencias SQL, pero se usan en contextos diferentes, dependiendo de si la consulta devuelve resultados o no. Peticiones a la BD Cuando una aplicaci\u00f3n se conecta a una base de datos, necesita ejecutar sentencias SQL desde el c\u00f3digo. En JDBC (Java/Kotlin), existen dos m\u00e9todos principales para ello: executeQuery() y executeUpdate() . Ambos permiten enviar instrucciones SQL al gestor de base de datos, pero se usan en situaciones diferentes: M\u00e9todo Uso principal Tipo de sentencia SQL Resultado que devuelve executeQuery() Realizar consultas SELECT Objeto ResultSet con los datos consultados executeUpdate() Realizar modificaciones INSERT, UPDATE, DELETE, DDL (CREATE, DROP, etc.) Un entero con el n\u00famero de filas afectadas execute() El m\u00e9todo execute() en JDBC se utiliza principalmente en los siguientes casos: Cuando no se sabe de antemano qu\u00e9 tipo de sentencia SQL se va a ejecutar o si la consulta puede ser tanto de consulta como de modificaci\u00f3n de datos. Para ejecutar sentencias SQL que pueden devolver varios resultados. En situaciones donde se necesita una gesti\u00f3n flexible de la ejecuci\u00f3n, ya que execute() devuelve un booleano: true si el resultado es un ResultSet (SELECT). false si el resultado es un entero (INSERT, UPDATE, DELETE,CREATE, ALTER) PrepareStatement VS CreateStatement Si necesitas... Usa... Consultas sin par\u00e1metros CreateStatement Consultas con datos del usuario PrepareStatement Seguridad frente a inyecciones SQL PrepareStatement Ejecutar muchas veces con distintos valores PrepareStatement Crear tablas o sentencias SQL complejas que no cambian CreateStatement Diferencia en la compilaci\u00f3n entre Statement y PreparedStatement Cada vez que env\u00edas una sentencia SQL al motor de base de datos, el motor debe hacer varios pasos: Parsear la consulta \u2192 comprobar que la sintaxis SQL es correcta. Compilar \u2192 convertir la consulta en un plan de ejecuci\u00f3n interno (c\u00f3mo buscar los datos, qu\u00e9 \u00edndices usar, etc.). Ejecutar \u2192 obtener los resultados. \ud83d\udd39 Con Statement Cada vez que llamas a executeQuery() o executeUpdate(), el SQL completo se env\u00eda como texto: val stmt = conn.createStatement() stmt.executeQuery(\"SELECT * FROM clientes WHERE ciudad = 'Valencia'\") stmt.executeQuery(\"SELECT * FROM clientes WHERE ciudad = 'Madrid'\") En este caso, el motor parsea y compila de nuevo las dos consultas, aunque solo cambia el valor de 'Valencia' a 'Madrid'. \ud83d\udd01 Es decir, se repite todo el trabajo de compilaci\u00f3n cada vez, lo que reduce el rendimiento si haces muchas consultas parecidas. \ud83d\udd39 Con PrepareStatement Aqu\u00ed, el SQL se env\u00eda una sola vez con par\u00e1metros (?): val pstmt = conn.prepareStatement(\"SELECT * FROM clientes WHERE ciudad = ?\") pstmt.setString(1, \"Valencia\") pstmt.executeQuery() pstmt.setString(1, \"Madrid\") pstmt.executeQuery() El motor solo compila la consulta una vez, y despu\u00e9s reutiliza el mismo plan de ejecuci\u00f3n cambiando solo el valor del par\u00e1metro. \u26a1 Esto ahorra tiempo y recursos, sobre todo cuando repites muchas veces la misma consulta con diferentes datos (por ejemplo, en bucles o inserciones masivas). \ud83d\udd39CRUD - SQlite \u00b6 Kotlin - Instrucciones Dentro del paquete SQlite del proyecto BDRelacionales , ya creado y conectado a la BD Tienda.sqlite , ubicada en la carpeta de recursos , incluiremos los ejemplos de este apartado. Estos ejemplos mostrar\u00e1n c\u00f3mo gestionar datos desde una aplicaci\u00f3n en Kotlin conectada a una base de datos relacional ligera, utilizando las tablas article , client , factura y linia_fac , tal y como se aprecia en el modelo relacional de la siguiente imagen. Tienda.sqlite Modelo Relacional Datos Paquete SQLite Operaciones CRUD Las operaciones m\u00e1s habituales para modificar los datos en una base de datos relacional son las conocidas como CRUD : CREATE : Permite a\u00f1adir nuevos registros a una tabla. READ : Permite consultar registros existentes. UPDATE : Permite modificar los valores de uno o varios registros existentes. DELETE : Permite eliminar registros de una tabla. CREATE (INSERT) Ejemplo_Insert.kt : Este fragmento a\u00f1ade un nuevo articulo \"00001\" a la tabla articles package SQLite import java.sql.DriverManager fun main() { val dbPath = \"src/main/resources/Tienda.sqlite\" val dbFile = java.io.File(dbPath) val url = \"jdbc:sqlite:${dbFile.absolutePath}\" DriverManager.getConnection(url).use { conn -> val sql = \"INSERT INTO article (cod_a, descrip) VALUES (?, ?)\" //conn.prepareStatement(sql) conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"00001\") stmt.setString(2, \"articulo de prueba 1\") stmt.executeUpdate() } } } UPDATE Ejemplo_Update.kt : Este c\u00f3digo actualiza la descripci\u00f3n del art\u00edculo \"00001\" package SQLite import java.sql.DriverManager fun main() { val dbPath = \"src/main/resources/Tienda.sqlite\" val dbFile = java.io.File(dbPath) val url = \"jdbc:sqlite:${dbFile.absolutePath}\" DriverManager.getConnection(url).use { conn -> val sql = \"UPDATE article SET descrip = ? WHERE cod_a = ?\" conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"descripci\u00f3n nueva\") stmt.setString(2, \"00001\") stmt.executeUpdate() } } } DELETE Ejemplo_Delete.kt : Este fragmento elimina el articulo \"00001\" package SQLite import java.sql.DriverManager fun main() { val dbPath = \"src/main/resources/Tienda.sqlite\" val dbFile = java.io.File(dbPath) val url = \"jdbc:sqlite:${dbFile.absolutePath}\" DriverManager.getConnection(url).use { conn -> val sql = \"DELETE FROM article WHERE cod_a = ?\" conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"00001\") stmt.executeUpdate() } } } READ (SELECT) Ejemplo_select_basico.kt : Consulta la tabla article. package SQLite import java.io.File import java.sql.DriverManager fun main() { val dbPath = \"src/main/resources/Tienda.sqlite\" val dbFile = File(dbPath) println(\"Ruta de la BD: ${dbFile.absolutePath}\") val url = \"jdbc:sqlite:${dbFile.absolutePath}\" DriverManager.getConnection(url).use { conn -> val sql = \"SELECT cod_a, descrip, preu, stock, stock_min FROM article\" conn.prepareStatement(sql).use { stmt -> stmt.executeQuery().use { rs -> println(\"Art\u00edculos disponibles:\") println(\"C\u00f3digo\\tDescripci\u00f3n\\tPrecio\\tStock\\tStock M\u00ednimo\") while (rs.next()) { val codA = rs.getString(\"cod_a\") val descrip = rs.getString(\"descrip\") val preu = rs.getDouble(\"preu\") val stock = rs.getInt(\"stock\") val stockMin = rs.getInt(\"stock_min\") println(\"$codA\\t$descrip\\t$preu\\t$stock\\t$stockMin\") } } } } } Ejemplo_join.kt : Este ejemplo obtiene las l\u00edneas de factura con nombre del art\u00edculo y ordenado por numero de factura y l\u00ednea. package SQLite import java.sql.DriverManager fun main() { val dbPath = \"src/main/resources/Tienda.sqlite\" val dbFile = java.io.File(dbPath) val url = \"jdbc:sqlite:${dbFile.absolutePath}\" DriverManager.getConnection(url).use { conn -> val sql = \"\"\" SELECT lf.num_f, lf.num_l, lf.cod_a, a.descrip, lf.quant, lf.preu FROM linia_fac lf JOIN article a ON lf.cod_a = a.cod_a ORDER BY lf.num_f, lf.num_l \"\"\".trimIndent() conn.prepareStatement(sql).use { stmt -> stmt.executeQuery().use { rs -> println(\"L\u00edneas de factura:\") println(\"Factura | L\u00ednea | Art\u00edculo | Descripci\u00f3n | Cantidad | Precio\") while (rs.next()) { val numF = rs.getInt(\"num_f\") val numL = rs.getInt(\"num_l\") val codA = rs.getString(\"cod_a\") val descrip = rs.getString(\"descrip\") val quant = rs.getInt(\"quant\") val preu = rs.getDouble(\"preu\") println(\"$numF\\t$numL\\t$codA\\t$descrip\\t$quant\\t$preu\") } } } } } \ud83d\udd39Liberaci\u00f3n de recursos \u00b6 Cuando una aplicaci\u00f3n accede a una base de datos, abre varios recursos internos que consumen memoria y conexiones activas en el sistema: La conexi\u00f3n con el servidor de base de datos (Connection) Las sentencias SQL preparadas (Statement o PreparedStatement) El resultado de la consulta (ResultSet) Estos recursos no se liberan autom\u00e1ticamente cuando se termina su uso (especialmente en Java o Kotlin con JDBC). Si no se cierran correctamente, se pueden producir problemas como: Fugas de memoria Bloqueo de conexiones (demasiadas conexiones abiertas) Degradaci\u00f3n del rendimiento Errores inesperados en la aplicaci\u00f3n \ud83d\udca1 En Kotlin, puedes usar use {} para cerrar recursos autom\u00e1ticamente al finalizar el bloque, tal y como hemos hecho en los ejemplos anteriores. Si no utilizas use {} en Kotlin (o try-with-resources en Java), entonces debes cerrar manualmente cada uno de los recursos abiertos (ResultSet, Statement y Connection) usando . close() , y normalmente deber\u00edas hacerlo dentro de un bloque finally para garantizar su cierre incluso si ocurre un error. El orden correcto de cierre es del m\u00e1s interno al m\u00e1s externo. \ud83d\udc49 Los siguientes ejemplos muestran como cerrar recursos abiertos sin use() , de forma manual y con el bloque try-catch-finally Ejemplo_cierre_manual.kt: Cierra los recurso de forma manual con close() package SQLite import java.sql.DriverManager import java.sql.Connection import java.sql.PreparedStatement import java.sql.ResultSet fun main() { val dbPath = \"src/main/resources/Tienda.sqlite\" val dbFile = java.io.File(dbPath) val url = \"jdbc:sqlite:${dbFile.absolutePath}\" val conn: Connection = DriverManager.getConnection(url) val sql = \"SELECT cod_a, descrip, preu, stock, stock_min FROM article\" val stmt: PreparedStatement = conn.prepareStatement(sql) val rs: ResultSet = stmt.executeQuery() println(\"Art\u00edculos:\") println(\"C\u00f3digo\\tDescripci\u00f3n\\tPrecio\\tStock\\tStock m\u00edn.\") while (rs.next()) { val codA = rs.getString(\"cod_a\") val descrip = rs.getString(\"descrip\") val preu = rs.getDouble(\"preu\") val stock = rs.getInt(\"stock\") val stockMin = rs.getInt(\"stock_min\") println(\"$codA\\t$descrip\\t$preu\\t$stock\\t$stockMin\") } rs.close() stmt.close() conn.close() } Ejemplo_cierre_try_catch.kt: Cierra los reursos con try-catch-finally package SQLite import java.sql.Connection import java.sql.DriverManager import java.sql.PreparedStatement import java.sql.ResultSet fun main() { val dbPath = \"src/main/resources/Tienda.sqlite\" val dbFile = java.io.File(dbPath) val url = \"jdbc:sqlite:${dbFile.absolutePath}\" var conn: Connection? = null var stmt: PreparedStatement? = null var rs: ResultSet? = null try { conn = DriverManager.getConnection(url) val sql = \"SELECT cod_a, descrip, preu, stock, stock_min FROM article\" stmt = conn.prepareStatement(sql) rs = stmt.executeQuery() println(\"Art\u00edculos:\") println(\"C\u00f3digo\\tDescripci\u00f3n\\tPrecio\\tStock\\tStock m\u00edn.\") while (rs.next()) { val codA = rs.getString(\"cod_a\") val descrip = rs.getString(\"descrip\") val preu = rs.getDouble(\"preu\") val stock = rs.getInt(\"stock\") val stockMin = rs.getInt(\"stock_min\") println(\"$codA\\t$descrip\\t$preu\\t$stock\\t$stockMin\") } } catch (e: Exception) { println(\"Error al acceder a la base de datos: ${e.message}\") } finally { try { rs?.close() } catch (e: Exception) { /* Ignorar */ } try { stmt?.close() } catch (e: Exception) { /* Ignorar */ } try { conn?.close() } catch (e: Exception) { /* Ignorar */ } } } \ud83d\udd39CRUD - PostgreSQL \u00b6 Hasta ahora hemos trabajado con ejemplos de operaciones CRUD (Crear, Leer, Actualizar y Borrar) utilizando SQLite , una base de datos ligera, f\u00e1cil de usar y sin necesidad de servidor, ideal para iniciarse en el acceso a datos desde Kotlin. Sin embargo, en entornos reales y profesionales, lo m\u00e1s habitual es trabajar con sistemas de gesti\u00f3n de bases de datos m\u00e1s potentes y completos, como PostgreSQL . A continuaci\u00f3n, aplicaremos lo aprendido en SQLite, pero ahora trabajando con PostgreSQL en dos contextos distintos : Base de datos remota : alojada en un servidor accesible mediante una direcci\u00f3n IP y credenciales. Base de datos local : replicada en un contenedor Docker , lo que resulta ideal para pruebas, desarrollo y aprendizaje en un entorno controlado. En ambos casos utilizaremos la misma base de datos, llamada geo_ad . Su versi\u00f3n remota estar\u00e1 disponible desde cualquier ubicaci\u00f3n, mientras que la local se generar\u00e1 a partir de ella siguiendo unas instrucciones que se os facilitar\u00e1n. Esquema de la BD geo_ad Modelo Relacional - Datos Paquete Postgres Kotlin - Instrucciones Dentro del paquete Postgres del proyecto BDRelacionales , incluiremos los ejemplos de este apartado. Estos ejemplos mostrar\u00e1n c\u00f3mo gestionar datos desde una aplicaci\u00f3n en Kotlin conectada a una base de datos relacional, utilizando las tablas institut , poblacio y comarca , tal y como se aprecia en el modelo relacional de la siguiente imagen. Configuraci\u00f3n de Dependencias (Gradle) Lo primero ser\u00e1 incluir las dependencia necesarias en build.gradle.kts // build.gradle.kts (para PostgreSQL) dependencies { implementation(\"org.postgresql:postgresql:42.6.0\") } \ud83d\uddc4\ufe0fServidor remoto \u00b6 La base de datos geo_ad se encuentra en una m\u00e1quina externa, por lo que se comporta como un recurso compartido en la nube. Para acceder a ella necesitamos establecer una conexi\u00f3n de red utilizando par\u00e1metros como los siguientes: Datos de conexi\u00f3n al servido remoto Servidor (host) : 89.36.214.106 Port : 5432 (es el puerto por defecto) Usuari : geo_ad Contrasenya : geo_ad Base de dades : geo_ad Ejemplo_conexion_Postgres_remota.kt package Postgres import java.sql.DriverManager object DatabaseRemota { private const val URL = \"jdbc:postgresql://89.36.214.106:5432/geo_ad\" private const val USER = \"geo_ad\" private const val PASSWORD = \"geo_ad\" fun getConnection() = DriverManager.getConnection(URL, USER, PASSWORD) } Operaciones CRUD Una vez conectados a la BD, ya podemos hacer operaciones CRUD sobre ella, utilizando el objeto de conexi\u00f3n correspondiente. Read (SELECT) Ejemplo_Select.kt : Consulta todos los institutos package Postgres fun main(args: Array<String>) { val sql = \"SELECT * FROM institut\" DatabaseLocal.getConnection().use { conn -> // DatabaseRemota si se conecta al servidor del instituto conn.prepareStatement(sql).use { stmt -> stmt.executeQuery().use { rs -> while (rs.next()) { print(\"\" + rs.getString(1) + \"\\t\") println(rs.getString(2)) } } } } } Create (INSERT) Ejemplo_Insert.kt : inserta un istituto de prueba. package Postgres fun main(args: Array<String>) { val sql =\"INSERT INTO institut (codi,nom,adreca,numero,codpostal,cod_m) VALUES(?,?,?,?,?,?)\" DatabaseLocal.getConnection().use { conn -> conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"00000000\") stmt.setString(2, \"IES PRUEBA\") stmt.setString(3, \"CASTELL\u00d3N\") stmt.setString(4, \"S/N\") stmt.setInt(5, 12560) stmt.setInt(6, 12040) stmt.executeUpdate() } } } Update (UPDATE) Ejemplo_Update.kt : actualiza el campo nombre del instituto de prueba insertado. package Postgres fun main() { val sql = \"UPDATE institut SET nom = ? WHERE codi = ?\" DatabaseLocal.getConnection().use { conn -> conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"IES PRUEBA 2\") stmt.setString(2, \"00000000\") stmt.executeUpdate() } } } Delete (DELETE) Ejemplo_Delete.kt : elimina el instituto de prueba insertado anteriormente. package Postgres fun main() { val sql = \"DELETE FROM institut WHERE codi = ?\" DatabaseLocal.getConnection().use { conn -> conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"00000000\") stmt.executeUpdate() } } } \ud83d\udc33 Docker \u00b6 Para poder programar y probar nuestras aplicaciones sin depender de la conexi\u00f3n externa, es muy \u00fatil replicar esa base de datos en local. La forma m\u00e1s sencilla y estandarizada de hacerlo es mediante Docker . Docker es una plataforma que permite ejecutar aplicaciones dentro de contenedores. Un contenedor es como una \u201ccaja\u201d que incluye todo lo necesario para que un servicio funcione: sistema operativo reducido, librer\u00edas, configuraci\u00f3n y la propia aplicaci\u00f3n. Para bases de datos, existen im\u00e1genes oficiales (Postgres, MySQL, MongoDB\u2026) que se pueden levantar en segundos. Intrucciones para replicar la BD en local (Docker) Las instrucciones para replicar la base de datos en Docker las pod\u00e9is encontrar en el siguiente enlace: Instrucciones \ud83d\udd0c Una vez hemos creada la BD en local ya podemos conectarnos a ella: Ejemplo_conexion_Postgres_local.kt package Postgres import java.sql.DriverManager object DatabaseLocal { private const val URL = \"jdbc:postgresql://localhost:5432/geo\" private const val USER = \"postgres\" private const val PASSWORD = \"postgres\" fun getConnection() = DriverManager.getConnection(URL, USER, PASSWORD) } Nota Los ejemplos anteriores de operaciones CRUD, realizados sobre el servidor remoto, son igualmente v\u00e1lidos para el servidor local, ya que la base de datos es la misma. \ud83d\udd39Data Class \u00b6 Hasta ahora hemos trabajado con bases de datos relacionales utilizando JDBC, construyendo consultas SQL, procesando los resultados con ResultSet y mostrando la informaci\u00f3n directamente por consola o almacen\u00e1ndola en estructuras b\u00e1sicas como listas o mapas. Sin embargo, cuando una aplicaci\u00f3n crece, se vuelve m\u00e1s c\u00f3modo y legible representar cada tabla de la base de datos como una clase del programa, cuyos atributos correspondan a las columnas de esa tabla. En Kotlin , esto se consigue de forma sencilla y elegante utilizando las data classes . Una data class (o clase de datos) es una clase especial de Kotlin dise\u00f1ada para almacenar y transportar informaci\u00f3n. El compilador genera autom\u00e1ticamente m\u00e9todos \u00fatiles como toString(), equals(), hashCode() y copy(), por lo que resulta ideal para representar filas (registros) de una tabla de base de datos. Su sint\u00e1xis b\u00e1sica es: data class NombreClase(val campo1: Tipo, val campo2: Tipo, ...) \ud83e\udde9 Ejemplo : representaci\u00f3n de una tabla cliente Supongamos que en la base de datos existe una tabla: CREATE TABLE cliente ( id INTEGER PRIMARY KEY, nombre TEXT, email TEXT ); Podemos definir la siguiente clase en Kotlin: data class Cliente( val id: Int, val nombre: String, val email: String ) Y al realizar una consulta con JDBC: val clientes = mutableListOf<Cliente>() val rs = stmt.executeQuery(\"SELECT * FROM cliente\") while (rs.next()) { clientes.add( Cliente( id = rs.getInt(\"id\"), nombre = rs.getString(\"nombre\"), email = rs.getString(\"email\") ) ) } En este ejemplo: Cada fila del ResultSet se convierte en un objeto Cliente. Todos los clientes recuperados se almacenan en una lista tipada ( List<Cliente> ). Posteriormente se pueden mostrar, modificar o procesar con facilidad. \ud83d\udccc Uso de data class en la BD Geo \u00b6 En este ejemplo replicamos la misma consulta que ya vimos anteriormente para obtener todos los institutos de la base de datos geo_ad alojada en el servidor remoto, pero ahora utilizando un data class en Kotlin. Esto nos permite representar cada fila del resultado como un objeto de tipo Institut , facilitando el tratamiento, la reutilizaci\u00f3n y la lectura del c\u00f3digo. Adem\u00e1s, almacenamos los resultados en una lista de objetos, lo que nos permite trabajar con ellos de forma m\u00e1s natural dentro de nuestro programa (listar, filtrar, transformar, etc.). Data Class: Institut package Postgres data class Institut( val codi: String, val nom: String?, val adreca: String?, val numero: String?, val codpostal: Int?, val codMunicipi: Int? ) Ejemplo_dataclass.kt package Postgres fun main() { val sql = \"SELECT * FROM institut\" val instituts = mutableListOf<Institut>() DatabaseRemota.getConnection().use { conn -> // Usa DatabaseRemota si es necesario conn.prepareStatement(sql).use { stmt -> stmt.executeQuery().use { rs -> while (rs.next()) { val institut = Institut( rs.getString(\"codi\"), rs.getString(\"nom\"), rs.getString(\"adreca\"), rs.getString(\"numero\"), rs.getInt(\"codpostal\"), rs.getInt(\"cod_m\") ) instituts.add(institut) } } } } println(\"\ud83c\udfeb Institutos encontrados:\") instituts.forEach { println(it) } }","title":"\ud83d\udd39Operaciones sobre la BD"},{"location":"Operaciones/#operaciones-sobre-la-bd","text":"En JDBC (Java Database Connectivity), las operaciones sobre la base de datos se realizan utilizando los siguientes objetos y m\u00e9todos: Connection , como ya se explic\u00f3 en el apartado anterior, establece el canal de comunicaci\u00f3n con el SGBD (PostgreSQL, MySQL, etc.) Los objetos PrepareStatement y CreateStatement se utlizan para enviar consultas SQL desde tu programa hacia la base de datos, pero se usan de forma distinta y tienen ventajas diferentes. ResultSet es un objeto que contiene el resultado de una consulta SQL, y permite recorrer fila a fila el conjunto de resultados, accediendo a cada campo por nombre o por posici\u00f3n. Los m\u00e9todos executeQuery() y executeUpdate() se utilizan para ejecutar sentencias SQL, pero se usan en contextos diferentes, dependiendo de si la consulta devuelve resultados o no. Peticiones a la BD Cuando una aplicaci\u00f3n se conecta a una base de datos, necesita ejecutar sentencias SQL desde el c\u00f3digo. En JDBC (Java/Kotlin), existen dos m\u00e9todos principales para ello: executeQuery() y executeUpdate() . Ambos permiten enviar instrucciones SQL al gestor de base de datos, pero se usan en situaciones diferentes: M\u00e9todo Uso principal Tipo de sentencia SQL Resultado que devuelve executeQuery() Realizar consultas SELECT Objeto ResultSet con los datos consultados executeUpdate() Realizar modificaciones INSERT, UPDATE, DELETE, DDL (CREATE, DROP, etc.) Un entero con el n\u00famero de filas afectadas execute() El m\u00e9todo execute() en JDBC se utiliza principalmente en los siguientes casos: Cuando no se sabe de antemano qu\u00e9 tipo de sentencia SQL se va a ejecutar o si la consulta puede ser tanto de consulta como de modificaci\u00f3n de datos. Para ejecutar sentencias SQL que pueden devolver varios resultados. En situaciones donde se necesita una gesti\u00f3n flexible de la ejecuci\u00f3n, ya que execute() devuelve un booleano: true si el resultado es un ResultSet (SELECT). false si el resultado es un entero (INSERT, UPDATE, DELETE,CREATE, ALTER) PrepareStatement VS CreateStatement Si necesitas... Usa... Consultas sin par\u00e1metros CreateStatement Consultas con datos del usuario PrepareStatement Seguridad frente a inyecciones SQL PrepareStatement Ejecutar muchas veces con distintos valores PrepareStatement Crear tablas o sentencias SQL complejas que no cambian CreateStatement Diferencia en la compilaci\u00f3n entre Statement y PreparedStatement Cada vez que env\u00edas una sentencia SQL al motor de base de datos, el motor debe hacer varios pasos: Parsear la consulta \u2192 comprobar que la sintaxis SQL es correcta. Compilar \u2192 convertir la consulta en un plan de ejecuci\u00f3n interno (c\u00f3mo buscar los datos, qu\u00e9 \u00edndices usar, etc.). Ejecutar \u2192 obtener los resultados. \ud83d\udd39 Con Statement Cada vez que llamas a executeQuery() o executeUpdate(), el SQL completo se env\u00eda como texto: val stmt = conn.createStatement() stmt.executeQuery(\"SELECT * FROM clientes WHERE ciudad = 'Valencia'\") stmt.executeQuery(\"SELECT * FROM clientes WHERE ciudad = 'Madrid'\") En este caso, el motor parsea y compila de nuevo las dos consultas, aunque solo cambia el valor de 'Valencia' a 'Madrid'. \ud83d\udd01 Es decir, se repite todo el trabajo de compilaci\u00f3n cada vez, lo que reduce el rendimiento si haces muchas consultas parecidas. \ud83d\udd39 Con PrepareStatement Aqu\u00ed, el SQL se env\u00eda una sola vez con par\u00e1metros (?): val pstmt = conn.prepareStatement(\"SELECT * FROM clientes WHERE ciudad = ?\") pstmt.setString(1, \"Valencia\") pstmt.executeQuery() pstmt.setString(1, \"Madrid\") pstmt.executeQuery() El motor solo compila la consulta una vez, y despu\u00e9s reutiliza el mismo plan de ejecuci\u00f3n cambiando solo el valor del par\u00e1metro. \u26a1 Esto ahorra tiempo y recursos, sobre todo cuando repites muchas veces la misma consulta con diferentes datos (por ejemplo, en bucles o inserciones masivas).","title":"Operaciones sobre la BD"},{"location":"Operaciones/#crud-sqlite","text":"Kotlin - Instrucciones Dentro del paquete SQlite del proyecto BDRelacionales , ya creado y conectado a la BD Tienda.sqlite , ubicada en la carpeta de recursos , incluiremos los ejemplos de este apartado. Estos ejemplos mostrar\u00e1n c\u00f3mo gestionar datos desde una aplicaci\u00f3n en Kotlin conectada a una base de datos relacional ligera, utilizando las tablas article , client , factura y linia_fac , tal y como se aprecia en el modelo relacional de la siguiente imagen. Tienda.sqlite Modelo Relacional Datos Paquete SQLite Operaciones CRUD Las operaciones m\u00e1s habituales para modificar los datos en una base de datos relacional son las conocidas como CRUD : CREATE : Permite a\u00f1adir nuevos registros a una tabla. READ : Permite consultar registros existentes. UPDATE : Permite modificar los valores de uno o varios registros existentes. DELETE : Permite eliminar registros de una tabla. CREATE (INSERT) Ejemplo_Insert.kt : Este fragmento a\u00f1ade un nuevo articulo \"00001\" a la tabla articles package SQLite import java.sql.DriverManager fun main() { val dbPath = \"src/main/resources/Tienda.sqlite\" val dbFile = java.io.File(dbPath) val url = \"jdbc:sqlite:${dbFile.absolutePath}\" DriverManager.getConnection(url).use { conn -> val sql = \"INSERT INTO article (cod_a, descrip) VALUES (?, ?)\" //conn.prepareStatement(sql) conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"00001\") stmt.setString(2, \"articulo de prueba 1\") stmt.executeUpdate() } } } UPDATE Ejemplo_Update.kt : Este c\u00f3digo actualiza la descripci\u00f3n del art\u00edculo \"00001\" package SQLite import java.sql.DriverManager fun main() { val dbPath = \"src/main/resources/Tienda.sqlite\" val dbFile = java.io.File(dbPath) val url = \"jdbc:sqlite:${dbFile.absolutePath}\" DriverManager.getConnection(url).use { conn -> val sql = \"UPDATE article SET descrip = ? WHERE cod_a = ?\" conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"descripci\u00f3n nueva\") stmt.setString(2, \"00001\") stmt.executeUpdate() } } } DELETE Ejemplo_Delete.kt : Este fragmento elimina el articulo \"00001\" package SQLite import java.sql.DriverManager fun main() { val dbPath = \"src/main/resources/Tienda.sqlite\" val dbFile = java.io.File(dbPath) val url = \"jdbc:sqlite:${dbFile.absolutePath}\" DriverManager.getConnection(url).use { conn -> val sql = \"DELETE FROM article WHERE cod_a = ?\" conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"00001\") stmt.executeUpdate() } } } READ (SELECT) Ejemplo_select_basico.kt : Consulta la tabla article. package SQLite import java.io.File import java.sql.DriverManager fun main() { val dbPath = \"src/main/resources/Tienda.sqlite\" val dbFile = File(dbPath) println(\"Ruta de la BD: ${dbFile.absolutePath}\") val url = \"jdbc:sqlite:${dbFile.absolutePath}\" DriverManager.getConnection(url).use { conn -> val sql = \"SELECT cod_a, descrip, preu, stock, stock_min FROM article\" conn.prepareStatement(sql).use { stmt -> stmt.executeQuery().use { rs -> println(\"Art\u00edculos disponibles:\") println(\"C\u00f3digo\\tDescripci\u00f3n\\tPrecio\\tStock\\tStock M\u00ednimo\") while (rs.next()) { val codA = rs.getString(\"cod_a\") val descrip = rs.getString(\"descrip\") val preu = rs.getDouble(\"preu\") val stock = rs.getInt(\"stock\") val stockMin = rs.getInt(\"stock_min\") println(\"$codA\\t$descrip\\t$preu\\t$stock\\t$stockMin\") } } } } } Ejemplo_join.kt : Este ejemplo obtiene las l\u00edneas de factura con nombre del art\u00edculo y ordenado por numero de factura y l\u00ednea. package SQLite import java.sql.DriverManager fun main() { val dbPath = \"src/main/resources/Tienda.sqlite\" val dbFile = java.io.File(dbPath) val url = \"jdbc:sqlite:${dbFile.absolutePath}\" DriverManager.getConnection(url).use { conn -> val sql = \"\"\" SELECT lf.num_f, lf.num_l, lf.cod_a, a.descrip, lf.quant, lf.preu FROM linia_fac lf JOIN article a ON lf.cod_a = a.cod_a ORDER BY lf.num_f, lf.num_l \"\"\".trimIndent() conn.prepareStatement(sql).use { stmt -> stmt.executeQuery().use { rs -> println(\"L\u00edneas de factura:\") println(\"Factura | L\u00ednea | Art\u00edculo | Descripci\u00f3n | Cantidad | Precio\") while (rs.next()) { val numF = rs.getInt(\"num_f\") val numL = rs.getInt(\"num_l\") val codA = rs.getString(\"cod_a\") val descrip = rs.getString(\"descrip\") val quant = rs.getInt(\"quant\") val preu = rs.getDouble(\"preu\") println(\"$numF\\t$numL\\t$codA\\t$descrip\\t$quant\\t$preu\") } } } } }","title":"\ud83d\udd39CRUD - SQlite"},{"location":"Operaciones/#liberacion-de-recursos","text":"Cuando una aplicaci\u00f3n accede a una base de datos, abre varios recursos internos que consumen memoria y conexiones activas en el sistema: La conexi\u00f3n con el servidor de base de datos (Connection) Las sentencias SQL preparadas (Statement o PreparedStatement) El resultado de la consulta (ResultSet) Estos recursos no se liberan autom\u00e1ticamente cuando se termina su uso (especialmente en Java o Kotlin con JDBC). Si no se cierran correctamente, se pueden producir problemas como: Fugas de memoria Bloqueo de conexiones (demasiadas conexiones abiertas) Degradaci\u00f3n del rendimiento Errores inesperados en la aplicaci\u00f3n \ud83d\udca1 En Kotlin, puedes usar use {} para cerrar recursos autom\u00e1ticamente al finalizar el bloque, tal y como hemos hecho en los ejemplos anteriores. Si no utilizas use {} en Kotlin (o try-with-resources en Java), entonces debes cerrar manualmente cada uno de los recursos abiertos (ResultSet, Statement y Connection) usando . close() , y normalmente deber\u00edas hacerlo dentro de un bloque finally para garantizar su cierre incluso si ocurre un error. El orden correcto de cierre es del m\u00e1s interno al m\u00e1s externo. \ud83d\udc49 Los siguientes ejemplos muestran como cerrar recursos abiertos sin use() , de forma manual y con el bloque try-catch-finally Ejemplo_cierre_manual.kt: Cierra los recurso de forma manual con close() package SQLite import java.sql.DriverManager import java.sql.Connection import java.sql.PreparedStatement import java.sql.ResultSet fun main() { val dbPath = \"src/main/resources/Tienda.sqlite\" val dbFile = java.io.File(dbPath) val url = \"jdbc:sqlite:${dbFile.absolutePath}\" val conn: Connection = DriverManager.getConnection(url) val sql = \"SELECT cod_a, descrip, preu, stock, stock_min FROM article\" val stmt: PreparedStatement = conn.prepareStatement(sql) val rs: ResultSet = stmt.executeQuery() println(\"Art\u00edculos:\") println(\"C\u00f3digo\\tDescripci\u00f3n\\tPrecio\\tStock\\tStock m\u00edn.\") while (rs.next()) { val codA = rs.getString(\"cod_a\") val descrip = rs.getString(\"descrip\") val preu = rs.getDouble(\"preu\") val stock = rs.getInt(\"stock\") val stockMin = rs.getInt(\"stock_min\") println(\"$codA\\t$descrip\\t$preu\\t$stock\\t$stockMin\") } rs.close() stmt.close() conn.close() } Ejemplo_cierre_try_catch.kt: Cierra los reursos con try-catch-finally package SQLite import java.sql.Connection import java.sql.DriverManager import java.sql.PreparedStatement import java.sql.ResultSet fun main() { val dbPath = \"src/main/resources/Tienda.sqlite\" val dbFile = java.io.File(dbPath) val url = \"jdbc:sqlite:${dbFile.absolutePath}\" var conn: Connection? = null var stmt: PreparedStatement? = null var rs: ResultSet? = null try { conn = DriverManager.getConnection(url) val sql = \"SELECT cod_a, descrip, preu, stock, stock_min FROM article\" stmt = conn.prepareStatement(sql) rs = stmt.executeQuery() println(\"Art\u00edculos:\") println(\"C\u00f3digo\\tDescripci\u00f3n\\tPrecio\\tStock\\tStock m\u00edn.\") while (rs.next()) { val codA = rs.getString(\"cod_a\") val descrip = rs.getString(\"descrip\") val preu = rs.getDouble(\"preu\") val stock = rs.getInt(\"stock\") val stockMin = rs.getInt(\"stock_min\") println(\"$codA\\t$descrip\\t$preu\\t$stock\\t$stockMin\") } } catch (e: Exception) { println(\"Error al acceder a la base de datos: ${e.message}\") } finally { try { rs?.close() } catch (e: Exception) { /* Ignorar */ } try { stmt?.close() } catch (e: Exception) { /* Ignorar */ } try { conn?.close() } catch (e: Exception) { /* Ignorar */ } } }","title":"\ud83d\udd39Liberaci\u00f3n de recursos"},{"location":"Operaciones/#crud-postgresql","text":"Hasta ahora hemos trabajado con ejemplos de operaciones CRUD (Crear, Leer, Actualizar y Borrar) utilizando SQLite , una base de datos ligera, f\u00e1cil de usar y sin necesidad de servidor, ideal para iniciarse en el acceso a datos desde Kotlin. Sin embargo, en entornos reales y profesionales, lo m\u00e1s habitual es trabajar con sistemas de gesti\u00f3n de bases de datos m\u00e1s potentes y completos, como PostgreSQL . A continuaci\u00f3n, aplicaremos lo aprendido en SQLite, pero ahora trabajando con PostgreSQL en dos contextos distintos : Base de datos remota : alojada en un servidor accesible mediante una direcci\u00f3n IP y credenciales. Base de datos local : replicada en un contenedor Docker , lo que resulta ideal para pruebas, desarrollo y aprendizaje en un entorno controlado. En ambos casos utilizaremos la misma base de datos, llamada geo_ad . Su versi\u00f3n remota estar\u00e1 disponible desde cualquier ubicaci\u00f3n, mientras que la local se generar\u00e1 a partir de ella siguiendo unas instrucciones que se os facilitar\u00e1n. Esquema de la BD geo_ad Modelo Relacional - Datos Paquete Postgres Kotlin - Instrucciones Dentro del paquete Postgres del proyecto BDRelacionales , incluiremos los ejemplos de este apartado. Estos ejemplos mostrar\u00e1n c\u00f3mo gestionar datos desde una aplicaci\u00f3n en Kotlin conectada a una base de datos relacional, utilizando las tablas institut , poblacio y comarca , tal y como se aprecia en el modelo relacional de la siguiente imagen. Configuraci\u00f3n de Dependencias (Gradle) Lo primero ser\u00e1 incluir las dependencia necesarias en build.gradle.kts // build.gradle.kts (para PostgreSQL) dependencies { implementation(\"org.postgresql:postgresql:42.6.0\") }","title":"\ud83d\udd39CRUD - PostgreSQL"},{"location":"Operaciones/#servidor-remoto","text":"La base de datos geo_ad se encuentra en una m\u00e1quina externa, por lo que se comporta como un recurso compartido en la nube. Para acceder a ella necesitamos establecer una conexi\u00f3n de red utilizando par\u00e1metros como los siguientes: Datos de conexi\u00f3n al servido remoto Servidor (host) : 89.36.214.106 Port : 5432 (es el puerto por defecto) Usuari : geo_ad Contrasenya : geo_ad Base de dades : geo_ad Ejemplo_conexion_Postgres_remota.kt package Postgres import java.sql.DriverManager object DatabaseRemota { private const val URL = \"jdbc:postgresql://89.36.214.106:5432/geo_ad\" private const val USER = \"geo_ad\" private const val PASSWORD = \"geo_ad\" fun getConnection() = DriverManager.getConnection(URL, USER, PASSWORD) } Operaciones CRUD Una vez conectados a la BD, ya podemos hacer operaciones CRUD sobre ella, utilizando el objeto de conexi\u00f3n correspondiente. Read (SELECT) Ejemplo_Select.kt : Consulta todos los institutos package Postgres fun main(args: Array<String>) { val sql = \"SELECT * FROM institut\" DatabaseLocal.getConnection().use { conn -> // DatabaseRemota si se conecta al servidor del instituto conn.prepareStatement(sql).use { stmt -> stmt.executeQuery().use { rs -> while (rs.next()) { print(\"\" + rs.getString(1) + \"\\t\") println(rs.getString(2)) } } } } } Create (INSERT) Ejemplo_Insert.kt : inserta un istituto de prueba. package Postgres fun main(args: Array<String>) { val sql =\"INSERT INTO institut (codi,nom,adreca,numero,codpostal,cod_m) VALUES(?,?,?,?,?,?)\" DatabaseLocal.getConnection().use { conn -> conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"00000000\") stmt.setString(2, \"IES PRUEBA\") stmt.setString(3, \"CASTELL\u00d3N\") stmt.setString(4, \"S/N\") stmt.setInt(5, 12560) stmt.setInt(6, 12040) stmt.executeUpdate() } } } Update (UPDATE) Ejemplo_Update.kt : actualiza el campo nombre del instituto de prueba insertado. package Postgres fun main() { val sql = \"UPDATE institut SET nom = ? WHERE codi = ?\" DatabaseLocal.getConnection().use { conn -> conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"IES PRUEBA 2\") stmt.setString(2, \"00000000\") stmt.executeUpdate() } } } Delete (DELETE) Ejemplo_Delete.kt : elimina el instituto de prueba insertado anteriormente. package Postgres fun main() { val sql = \"DELETE FROM institut WHERE codi = ?\" DatabaseLocal.getConnection().use { conn -> conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"00000000\") stmt.executeUpdate() } } }","title":"\ud83d\uddc4\ufe0fServidor remoto"},{"location":"Operaciones/#docker","text":"Para poder programar y probar nuestras aplicaciones sin depender de la conexi\u00f3n externa, es muy \u00fatil replicar esa base de datos en local. La forma m\u00e1s sencilla y estandarizada de hacerlo es mediante Docker . Docker es una plataforma que permite ejecutar aplicaciones dentro de contenedores. Un contenedor es como una \u201ccaja\u201d que incluye todo lo necesario para que un servicio funcione: sistema operativo reducido, librer\u00edas, configuraci\u00f3n y la propia aplicaci\u00f3n. Para bases de datos, existen im\u00e1genes oficiales (Postgres, MySQL, MongoDB\u2026) que se pueden levantar en segundos. Intrucciones para replicar la BD en local (Docker) Las instrucciones para replicar la base de datos en Docker las pod\u00e9is encontrar en el siguiente enlace: Instrucciones \ud83d\udd0c Una vez hemos creada la BD en local ya podemos conectarnos a ella: Ejemplo_conexion_Postgres_local.kt package Postgres import java.sql.DriverManager object DatabaseLocal { private const val URL = \"jdbc:postgresql://localhost:5432/geo\" private const val USER = \"postgres\" private const val PASSWORD = \"postgres\" fun getConnection() = DriverManager.getConnection(URL, USER, PASSWORD) } Nota Los ejemplos anteriores de operaciones CRUD, realizados sobre el servidor remoto, son igualmente v\u00e1lidos para el servidor local, ya que la base de datos es la misma.","title":"\ud83d\udc33 Docker"},{"location":"Operaciones/#data-class","text":"Hasta ahora hemos trabajado con bases de datos relacionales utilizando JDBC, construyendo consultas SQL, procesando los resultados con ResultSet y mostrando la informaci\u00f3n directamente por consola o almacen\u00e1ndola en estructuras b\u00e1sicas como listas o mapas. Sin embargo, cuando una aplicaci\u00f3n crece, se vuelve m\u00e1s c\u00f3modo y legible representar cada tabla de la base de datos como una clase del programa, cuyos atributos correspondan a las columnas de esa tabla. En Kotlin , esto se consigue de forma sencilla y elegante utilizando las data classes . Una data class (o clase de datos) es una clase especial de Kotlin dise\u00f1ada para almacenar y transportar informaci\u00f3n. El compilador genera autom\u00e1ticamente m\u00e9todos \u00fatiles como toString(), equals(), hashCode() y copy(), por lo que resulta ideal para representar filas (registros) de una tabla de base de datos. Su sint\u00e1xis b\u00e1sica es: data class NombreClase(val campo1: Tipo, val campo2: Tipo, ...) \ud83e\udde9 Ejemplo : representaci\u00f3n de una tabla cliente Supongamos que en la base de datos existe una tabla: CREATE TABLE cliente ( id INTEGER PRIMARY KEY, nombre TEXT, email TEXT ); Podemos definir la siguiente clase en Kotlin: data class Cliente( val id: Int, val nombre: String, val email: String ) Y al realizar una consulta con JDBC: val clientes = mutableListOf<Cliente>() val rs = stmt.executeQuery(\"SELECT * FROM cliente\") while (rs.next()) { clientes.add( Cliente( id = rs.getInt(\"id\"), nombre = rs.getString(\"nombre\"), email = rs.getString(\"email\") ) ) } En este ejemplo: Cada fila del ResultSet se convierte en un objeto Cliente. Todos los clientes recuperados se almacenan en una lista tipada ( List<Cliente> ). Posteriormente se pueden mostrar, modificar o procesar con facilidad.","title":"\ud83d\udd39Data Class"},{"location":"Operaciones/#uso-de-data-class-en-la-bd-geo","text":"En este ejemplo replicamos la misma consulta que ya vimos anteriormente para obtener todos los institutos de la base de datos geo_ad alojada en el servidor remoto, pero ahora utilizando un data class en Kotlin. Esto nos permite representar cada fila del resultado como un objeto de tipo Institut , facilitando el tratamiento, la reutilizaci\u00f3n y la lectura del c\u00f3digo. Adem\u00e1s, almacenamos los resultados en una lista de objetos, lo que nos permite trabajar con ellos de forma m\u00e1s natural dentro de nuestro programa (listar, filtrar, transformar, etc.). Data Class: Institut package Postgres data class Institut( val codi: String, val nom: String?, val adreca: String?, val numero: String?, val codpostal: Int?, val codMunicipi: Int? ) Ejemplo_dataclass.kt package Postgres fun main() { val sql = \"SELECT * FROM institut\" val instituts = mutableListOf<Institut>() DatabaseRemota.getConnection().use { conn -> // Usa DatabaseRemota si es necesario conn.prepareStatement(sql).use { stmt -> stmt.executeQuery().use { rs -> while (rs.next()) { val institut = Institut( rs.getString(\"codi\"), rs.getString(\"nom\"), rs.getString(\"adreca\"), rs.getString(\"numero\"), rs.getInt(\"codpostal\"), rs.getInt(\"cod_m\") ) instituts.add(institut) } } } } println(\"\ud83c\udfeb Institutos encontrados:\") instituts.forEach { println(it) } }","title":"\ud83d\udccc Uso de data class en la BD Geo"},{"location":"Procedimientos/","text":"Funciones y Procedimientos almacenados \u00b6 Tanto las funciones como los procedimientos almacenados son bloques de c\u00f3digo que se guardan en el servidor de la base de datos y que encapsulan una serie de instrucciones SQL. Se usan para: Reutilizar operaciones complejas Organizar mejor la l\u00f3gica de negocio Mejorar el rendimiento (menos tr\u00e1fico entre app y BD) Mantener la integridad de datos Diferencia entre Funciones y Procedimientos Una funci\u00f3n est\u00e1 dise\u00f1ada para calcular y devolver un resultado . Se puede usar directamente dentro de una consulta SQL como parte de un SELECT, WHERE, ORDER BY, etc. Las funciones siempre devuelven un valor, que puede ser escalar (un n\u00famero, texto...), una fila o una tabla. Un procedimiento sirve para ejecutar acciones dentro de la base de datos, como insertar registros, modificar datos o gestionar operaciones en bloque. No devuelve un valor directamente (aunque puede usar par\u00e1metros de salida), y se ejecuta con CALL, no con SELECT. Nota SQLite no soporta funciones ni procedimientos almacenados como lo hacen bases de datos como PostgreSQL, MySQL u Oracle. Sin embargo, puedes simular su comportamiento mediante funciones definidas en la aplicaci\u00f3n, o vistas y triggers. Las funciones (FUNCTION) y los procedimientos (PROCEDURE) no se crean desde el lenguaje Kotlin , ya que son elementos propios del sistema gestor de bases de datos (SGBD), en este caso PostgreSQL . Para definirlos, se utiliza SQL y se ejecutan directamente sobre la base de datos a trav\u00e9s de un cliente SQL. Una vez que las funciones o procedimientos est\u00e1n creados en la base de datos, se pueden utilizar perfectamente desde Kotlin a trav\u00e9s de JDBC , igual que se hace con cualquier consulta SQL: Las funciones se invocan con SELECT nombre_funcion(...) Los procedimientos se llaman con CALL nombre_procedimiento(...) Y desde Kotlin, se gestionan mediante objetos como PreparedStatement y CallableStatement . \ud83d\udd39Funciones (FUNCTION) \u00b6 Una funci\u00f3n en PostgreSQL es un bloque que: Puede aceptar par\u00e1metros Devuelve siempre un valor (escalar, tabla o compuesto) Se puede usar en consultas SQL (SELECT, WHERE, etc.) Puede tener IN, OUT, INOUT Sintaxis b\u00e1sica en PostgreSql CREATE [OR REPLACE] FUNCTION nombre_funcion(par\u00e1metros) RETURNS tipo_de_dato LANGUAGE plpgsql AS $$ BEGIN -- instrucciones RETURN valor; END; $$; Tipo de retorno \u00bfQu\u00e9 devuelve? Ejemplo de uso INTEGER , TEXT , etc. Un \u00fanico valor escalar RETURNS INTEGER RETURN x * x; TABLE(...) Una tabla (varias columnas y filas) RETURNS TABLE(codi TEXT, nom TEXT) RETURN QUERY ... SETOF INTEGER Un conjunto de valores escalares RETURNS SETOF INTEGER RETURN NEXT i; SETOF RECORD Muchas filas con estructura din\u00e1mica RETURNS SETOF RECORD %ROWTYPE Una fila con la estructura de una tabla existente RETURNS institut%ROWTYPE SELECT * INTO reg ... RECORD Una sola fila con columnas gen\u00e9ricas RETURNS RECORD SELECT ... INTO resultado; Tipo personalizado Una estructura definida con CREATE TYPE RETURNS tipo_personalizado Los siguientes ejemplos se han creado utilizando el cliente SQL DBeaver y la BD Geo_docker . Funciones que devuelve un valor : Ejemplo en SQL: Funci\u00f3n que devuelve el cuadrado de un n\u00famero. CREATE OR REPLACE FUNCTION cuadrado(x INTEGER) RETURNS INTEGER AS $$ BEGIN RETURN x * x; END; $$ LANGUAGE plpgsql; La llamada desde SQL ser\u00eda: SELECT cuadrado(5); --Devuelve 25 En Kotlin la llamda a la funci\u00f3n ser\u00eda: Ejemplo_cuadrado.kt fun main() { DatabaseLocal.getConnection().use { conn -> val sql = \"SELECT cuadrado(?)\" conn.prepareStatement(sql).use { stmt -> stmt.setInt(1, 6) // por ejemplo: x = 6 val rs = stmt.executeQuery() if (rs.next()) { val resultado = rs.getInt(1) println(\"El cuadrado de 6 es: $resultado\") } } } } Fucniones que devuelven una tabla Ejemplo en SQL: Funci\u00f3n que devuelve todos los institutos junto con su poblaci\u00f3n y comarca. CREATE OR REPLACE FUNCTION obtener_instituts() RETURNS TABLE ( codi TEXT, nom TEXT, municipi TEXT, comarca TEXT ) AS $$ SELECT i.codi, i.nom, p.nom AS municipi, c.nom_c AS comarca FROM institut i JOIN poblacio p ON i.cod_m = p.cod_m JOIN comarca c ON p.nom_c = c.nom_c ORDER BY comarca, municipi; $$ LANGUAGE sql; La llamada desde SQL ser\u00eda: SELECT * FROM obtener_instituts(); En Kotlin la llamda a la funci\u00f3n ser\u00eda: Ejemplo_fun_obtener_institutos.kt fun main() { DatabaseLocal.getConnection().use { conn -> val sql = \"SELECT * FROM obtener_instituts()\" conn.prepareStatement(sql).use { stmt -> val rs = stmt.executeQuery() while (rs.next()) { val codi = rs.getString(\"codi\") val nom = rs.getString(\"nom\") val municipi = rs.getString(\"municipi\") val comarca = rs.getString(\"comarca\") println(\"Institut: $codi - $nom ($municipi, $comarca)\") } } } } Fucniones que aceptan filtros como par\u00e1metros Ejemplo en SQL: Funci\u00f3n que devuelve los institutos de una comarca. CREATE OR REPLACE FUNCTION instituts_de_comarca(p_nom_c TEXT) RETURNS TABLE ( codi TEXT, nom TEXT, municipi TEXT, comarca TEXT ) AS $$ SELECT i.codi, i.nom, p.nom AS municipi, c.nom_c AS comarca FROM institut i JOIN poblacio p ON i.cod_m = p.cod_m JOIN comarca c ON p.nom_c = c.nom_c WHERE c.nom_c = p_nom_c ORDER BY municipi; $$ LANGUAGE sql; La llamada desde SQL ser\u00eda: SELECT * FROM instituts_de_comarca('Plana Baixa'); En Kotlin la llamda a la funci\u00f3n ser\u00eda: Ejemplo_fun_instituts_de_comarca.kt fun main() { DatabaseLocal.getConnection().use { conn -> val sql = \"SELECT * FROM instituts_de_comarca(?)\" conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"Plana Baixa\") // Par\u00e1metro de entrada val rs = stmt.executeQuery() while (rs.next()) { val codi = rs.getString(\"codi\") val nom = rs.getString(\"nom\") val municipi = rs.getString(\"municipi\") val comarca = rs.getString(\"comarca\") println(\"Institut: $codi - $nom ($municipi, $comarca)\") } } } } \ud83d\udd39Procedimientos (PROCEDURE) \u00b6 Los procedimientos no devuelven valores directamente, a diferencia de las funciones, pero pueden tener par\u00e1metros de entrada (IN), salida (OUT) o ambos (INOUT). Se utilizan para realizar tareas como: Inserciones o actualizaciones complejas Validaciones Operaciones en bloque Ejecuci\u00f3n de l\u00f3gica con control de flujo Agrupaci\u00f3n de instrucciones dentro de una transacci\u00f3n Sintaxis b\u00e1sica en PostgreSql CREATE [OR REPLACE] PROCEDURE nombre_procedimiento( [par\u00e1metro1 tipo [IN|OUT|INOUT]], ... ) AS $$ BEGIN -- cuerpo del procedimiento END; $$ LANGUAGE plpgsql; Ejemplo en SQL: Procedimiento que inserta un nuevo instituto y muestra un aviso. CREATE OR REPLACE PROCEDURE insertar_institut_resultado( IN p_codi VARCHAR, IN p_nom VARCHAR, IN p_cod_m INTEGER, OUT resultado TEXT ) AS $$ BEGIN -- \u00bfMunicipio existe? IF NOT EXISTS (SELECT 1 FROM poblacio WHERE cod_m = p_cod_m) THEN resultado := 'MUNICIPIO_NO_ENCONTRADO'; RETURN; END IF; -- \u00bfInstituto ya existe? IF EXISTS (SELECT 1 FROM institut WHERE codi = p_codi) THEN resultado := 'EXISTENTE'; RETURN; END IF; -- Insertar instituto INSERT INTO institut (codi, nom, cod_m) VALUES (p_codi, p_nom, p_cod_m); resultado := 'INSERTADO'; END; $$ LANGUAGE plpgsql; La llamada desde SQL ser\u00eda: CALL insertar_institut_resultado('I999', 'Institut Experimental', 12028, NULL); En Kotlin la llamda a la funci\u00f3n ser\u00eda: Ejemplo_pro_insertar_institut_resultado.kt import java.sql.Types fun main() { DatabaseLocal.getConnection().use { conn -> val sql = \"Call insertar_institut_resultado(?, ?, ?, ?)\" conn.prepareCall(sql).use { stmt -> stmt.setString(1, \"I999\") stmt.setString(2, \"Institut Experimental\") stmt.setInt(3, 12028) stmt.registerOutParameter(4, Types.VARCHAR) stmt.execute() val resultado = stmt.getString(4) println(\"Resultado: $resultado\") } } } \ud83d\udcca Resumen diferencias entre funci\u00f3n y procedimiento en PostgreSQL \u00b6 Caracter\u00edstica FUNCI\u00d3N ( FUNCTION ) PROCEDIMIENTO ( PROCEDURE ) \ud83d\udd01 Devuelve un valor \u2705 S\u00ed (con RETURN ) \u274c No directamente \ud83d\udce5 Par\u00e1metros de entrada ( IN ) \u2705 S\u00ed \u2705 S\u00ed \ud83d\udce4 Par\u00e1metros de salida ( OUT ) \u2705 S\u00ed (como OUT , INOUT , o RETURNS ) \u2705 S\u00ed ( OUT , INOUT ) \ud83d\udccc Se invoca con\u2026 SELECT nombre_funcion(...) CALL nombre_procedimiento(...) \ud83d\udcca Usable en consultas SQL \u2705 S\u00ed (puede ir en SELECT , WHERE , etc.) \u274c No \ud83d\udd04 Puede devolver tablas \u2705 S\u00ed ( RETURNS TABLE o SETOF ) \u274c No directamente \ud83d\udd01 Puede usar RETURN \u2705 Obligatorio \u274c No se usa RETURN , sino solo CALL \ud83e\uddf1 Uso t\u00edpico C\u00e1lculos, validaciones, funciones reutilizables Procesos complejos, l\u00f3gica de negocio, transacciones","title":"\ud83d\udd39Funciones y Procedimientos almacenados"},{"location":"Procedimientos/#funciones-y-procedimientos-almacenados","text":"Tanto las funciones como los procedimientos almacenados son bloques de c\u00f3digo que se guardan en el servidor de la base de datos y que encapsulan una serie de instrucciones SQL. Se usan para: Reutilizar operaciones complejas Organizar mejor la l\u00f3gica de negocio Mejorar el rendimiento (menos tr\u00e1fico entre app y BD) Mantener la integridad de datos Diferencia entre Funciones y Procedimientos Una funci\u00f3n est\u00e1 dise\u00f1ada para calcular y devolver un resultado . Se puede usar directamente dentro de una consulta SQL como parte de un SELECT, WHERE, ORDER BY, etc. Las funciones siempre devuelven un valor, que puede ser escalar (un n\u00famero, texto...), una fila o una tabla. Un procedimiento sirve para ejecutar acciones dentro de la base de datos, como insertar registros, modificar datos o gestionar operaciones en bloque. No devuelve un valor directamente (aunque puede usar par\u00e1metros de salida), y se ejecuta con CALL, no con SELECT. Nota SQLite no soporta funciones ni procedimientos almacenados como lo hacen bases de datos como PostgreSQL, MySQL u Oracle. Sin embargo, puedes simular su comportamiento mediante funciones definidas en la aplicaci\u00f3n, o vistas y triggers. Las funciones (FUNCTION) y los procedimientos (PROCEDURE) no se crean desde el lenguaje Kotlin , ya que son elementos propios del sistema gestor de bases de datos (SGBD), en este caso PostgreSQL . Para definirlos, se utiliza SQL y se ejecutan directamente sobre la base de datos a trav\u00e9s de un cliente SQL. Una vez que las funciones o procedimientos est\u00e1n creados en la base de datos, se pueden utilizar perfectamente desde Kotlin a trav\u00e9s de JDBC , igual que se hace con cualquier consulta SQL: Las funciones se invocan con SELECT nombre_funcion(...) Los procedimientos se llaman con CALL nombre_procedimiento(...) Y desde Kotlin, se gestionan mediante objetos como PreparedStatement y CallableStatement .","title":"Funciones y Procedimientos almacenados"},{"location":"Procedimientos/#funciones-function","text":"Una funci\u00f3n en PostgreSQL es un bloque que: Puede aceptar par\u00e1metros Devuelve siempre un valor (escalar, tabla o compuesto) Se puede usar en consultas SQL (SELECT, WHERE, etc.) Puede tener IN, OUT, INOUT Sintaxis b\u00e1sica en PostgreSql CREATE [OR REPLACE] FUNCTION nombre_funcion(par\u00e1metros) RETURNS tipo_de_dato LANGUAGE plpgsql AS $$ BEGIN -- instrucciones RETURN valor; END; $$; Tipo de retorno \u00bfQu\u00e9 devuelve? Ejemplo de uso INTEGER , TEXT , etc. Un \u00fanico valor escalar RETURNS INTEGER RETURN x * x; TABLE(...) Una tabla (varias columnas y filas) RETURNS TABLE(codi TEXT, nom TEXT) RETURN QUERY ... SETOF INTEGER Un conjunto de valores escalares RETURNS SETOF INTEGER RETURN NEXT i; SETOF RECORD Muchas filas con estructura din\u00e1mica RETURNS SETOF RECORD %ROWTYPE Una fila con la estructura de una tabla existente RETURNS institut%ROWTYPE SELECT * INTO reg ... RECORD Una sola fila con columnas gen\u00e9ricas RETURNS RECORD SELECT ... INTO resultado; Tipo personalizado Una estructura definida con CREATE TYPE RETURNS tipo_personalizado Los siguientes ejemplos se han creado utilizando el cliente SQL DBeaver y la BD Geo_docker . Funciones que devuelve un valor : Ejemplo en SQL: Funci\u00f3n que devuelve el cuadrado de un n\u00famero. CREATE OR REPLACE FUNCTION cuadrado(x INTEGER) RETURNS INTEGER AS $$ BEGIN RETURN x * x; END; $$ LANGUAGE plpgsql; La llamada desde SQL ser\u00eda: SELECT cuadrado(5); --Devuelve 25 En Kotlin la llamda a la funci\u00f3n ser\u00eda: Ejemplo_cuadrado.kt fun main() { DatabaseLocal.getConnection().use { conn -> val sql = \"SELECT cuadrado(?)\" conn.prepareStatement(sql).use { stmt -> stmt.setInt(1, 6) // por ejemplo: x = 6 val rs = stmt.executeQuery() if (rs.next()) { val resultado = rs.getInt(1) println(\"El cuadrado de 6 es: $resultado\") } } } } Fucniones que devuelven una tabla Ejemplo en SQL: Funci\u00f3n que devuelve todos los institutos junto con su poblaci\u00f3n y comarca. CREATE OR REPLACE FUNCTION obtener_instituts() RETURNS TABLE ( codi TEXT, nom TEXT, municipi TEXT, comarca TEXT ) AS $$ SELECT i.codi, i.nom, p.nom AS municipi, c.nom_c AS comarca FROM institut i JOIN poblacio p ON i.cod_m = p.cod_m JOIN comarca c ON p.nom_c = c.nom_c ORDER BY comarca, municipi; $$ LANGUAGE sql; La llamada desde SQL ser\u00eda: SELECT * FROM obtener_instituts(); En Kotlin la llamda a la funci\u00f3n ser\u00eda: Ejemplo_fun_obtener_institutos.kt fun main() { DatabaseLocal.getConnection().use { conn -> val sql = \"SELECT * FROM obtener_instituts()\" conn.prepareStatement(sql).use { stmt -> val rs = stmt.executeQuery() while (rs.next()) { val codi = rs.getString(\"codi\") val nom = rs.getString(\"nom\") val municipi = rs.getString(\"municipi\") val comarca = rs.getString(\"comarca\") println(\"Institut: $codi - $nom ($municipi, $comarca)\") } } } } Fucniones que aceptan filtros como par\u00e1metros Ejemplo en SQL: Funci\u00f3n que devuelve los institutos de una comarca. CREATE OR REPLACE FUNCTION instituts_de_comarca(p_nom_c TEXT) RETURNS TABLE ( codi TEXT, nom TEXT, municipi TEXT, comarca TEXT ) AS $$ SELECT i.codi, i.nom, p.nom AS municipi, c.nom_c AS comarca FROM institut i JOIN poblacio p ON i.cod_m = p.cod_m JOIN comarca c ON p.nom_c = c.nom_c WHERE c.nom_c = p_nom_c ORDER BY municipi; $$ LANGUAGE sql; La llamada desde SQL ser\u00eda: SELECT * FROM instituts_de_comarca('Plana Baixa'); En Kotlin la llamda a la funci\u00f3n ser\u00eda: Ejemplo_fun_instituts_de_comarca.kt fun main() { DatabaseLocal.getConnection().use { conn -> val sql = \"SELECT * FROM instituts_de_comarca(?)\" conn.prepareStatement(sql).use { stmt -> stmt.setString(1, \"Plana Baixa\") // Par\u00e1metro de entrada val rs = stmt.executeQuery() while (rs.next()) { val codi = rs.getString(\"codi\") val nom = rs.getString(\"nom\") val municipi = rs.getString(\"municipi\") val comarca = rs.getString(\"comarca\") println(\"Institut: $codi - $nom ($municipi, $comarca)\") } } } }","title":"\ud83d\udd39Funciones (FUNCTION)"},{"location":"Procedimientos/#procedimientos-procedure","text":"Los procedimientos no devuelven valores directamente, a diferencia de las funciones, pero pueden tener par\u00e1metros de entrada (IN), salida (OUT) o ambos (INOUT). Se utilizan para realizar tareas como: Inserciones o actualizaciones complejas Validaciones Operaciones en bloque Ejecuci\u00f3n de l\u00f3gica con control de flujo Agrupaci\u00f3n de instrucciones dentro de una transacci\u00f3n Sintaxis b\u00e1sica en PostgreSql CREATE [OR REPLACE] PROCEDURE nombre_procedimiento( [par\u00e1metro1 tipo [IN|OUT|INOUT]], ... ) AS $$ BEGIN -- cuerpo del procedimiento END; $$ LANGUAGE plpgsql; Ejemplo en SQL: Procedimiento que inserta un nuevo instituto y muestra un aviso. CREATE OR REPLACE PROCEDURE insertar_institut_resultado( IN p_codi VARCHAR, IN p_nom VARCHAR, IN p_cod_m INTEGER, OUT resultado TEXT ) AS $$ BEGIN -- \u00bfMunicipio existe? IF NOT EXISTS (SELECT 1 FROM poblacio WHERE cod_m = p_cod_m) THEN resultado := 'MUNICIPIO_NO_ENCONTRADO'; RETURN; END IF; -- \u00bfInstituto ya existe? IF EXISTS (SELECT 1 FROM institut WHERE codi = p_codi) THEN resultado := 'EXISTENTE'; RETURN; END IF; -- Insertar instituto INSERT INTO institut (codi, nom, cod_m) VALUES (p_codi, p_nom, p_cod_m); resultado := 'INSERTADO'; END; $$ LANGUAGE plpgsql; La llamada desde SQL ser\u00eda: CALL insertar_institut_resultado('I999', 'Institut Experimental', 12028, NULL); En Kotlin la llamda a la funci\u00f3n ser\u00eda: Ejemplo_pro_insertar_institut_resultado.kt import java.sql.Types fun main() { DatabaseLocal.getConnection().use { conn -> val sql = \"Call insertar_institut_resultado(?, ?, ?, ?)\" conn.prepareCall(sql).use { stmt -> stmt.setString(1, \"I999\") stmt.setString(2, \"Institut Experimental\") stmt.setInt(3, 12028) stmt.registerOutParameter(4, Types.VARCHAR) stmt.execute() val resultado = stmt.getString(4) println(\"Resultado: $resultado\") } } }","title":"\ud83d\udd39Procedimientos (PROCEDURE)"},{"location":"Procedimientos/#resumen-diferencias-entre-funcion-y-procedimiento-en-postgresql","text":"Caracter\u00edstica FUNCI\u00d3N ( FUNCTION ) PROCEDIMIENTO ( PROCEDURE ) \ud83d\udd01 Devuelve un valor \u2705 S\u00ed (con RETURN ) \u274c No directamente \ud83d\udce5 Par\u00e1metros de entrada ( IN ) \u2705 S\u00ed \u2705 S\u00ed \ud83d\udce4 Par\u00e1metros de salida ( OUT ) \u2705 S\u00ed (como OUT , INOUT , o RETURNS ) \u2705 S\u00ed ( OUT , INOUT ) \ud83d\udccc Se invoca con\u2026 SELECT nombre_funcion(...) CALL nombre_procedimiento(...) \ud83d\udcca Usable en consultas SQL \u2705 S\u00ed (puede ir en SELECT , WHERE , etc.) \u274c No \ud83d\udd04 Puede devolver tablas \u2705 S\u00ed ( RETURNS TABLE o SETOF ) \u274c No directamente \ud83d\udd01 Puede usar RETURN \u2705 Obligatorio \u274c No se usa RETURN , sino solo CALL \ud83e\uddf1 Uso t\u00edpico C\u00e1lculos, validaciones, funciones reutilizables Procesos complejos, l\u00f3gica de negocio, transacciones","title":"\ud83d\udcca Resumen diferencias entre funci\u00f3n y procedimiento en PostgreSQL"},{"location":"RA_CE/","text":"RA 2 \u2013 Desarrolla aplicaciones que gestionan informaci\u00f3n almacenada en bases de datos relacionales identificando y utilizando mecanismos de conexi\u00f3n. \u00b6 Criterio de Evaluaci\u00f3n Contenido Relacionado a) Ventajas e inconvenientes de utilizar conectores - Conectores JDBC - Bibliotecas ORM (Hibernate, JPA) - Comparativa: rendimiento, facilidad, portabilidad b) Gestores de bases de datos embebidos e independientes - SQLite (embebido) - PostgreSQL, MySQL (independientes) - Casos de uso y configuraci\u00f3n c) Uso del conector id\u00f3neo en la aplicaci\u00f3n - Selecci\u00f3n de driver JDBC adecuado - Configuraci\u00f3n del archivo pom.xml o build.gradle d) Establecimiento de la conexi\u00f3n - Clases DriverManager , Connection - Manejo de excepciones SQL - Pruebas de conexi\u00f3n e) Definici\u00f3n de la estructura de la base de datos - Modelado l\u00f3gico y f\u00edsico - Esquemas y tablas - Tipos de datos y restricciones f) Aplicaciones que modifican el contenido de la base de datos - Operaciones CRUD: INSERT , UPDATE , DELETE - Preparaci\u00f3n de sentencias ( PreparedStatement ) g) Definici\u00f3n de objetos para almacenar resultados - Objetos DTO/POJO - ResultSet y mapeo de resultados a objetos Kotlin/Java h) Aplicaciones que efect\u00faan consultas - Consultas SELECT simples y complejas - Filtros, ordenaciones y uniones ( JOIN ) i) Eliminaci\u00f3n de objetos tras su uso - Cierre de conexiones, sentencias y resultados - Uso de try-with-resources o use {} en Kotlin j) Gesti\u00f3n de transacciones - Comandos commit , rollback - Control manual y autom\u00e1tico de transacciones k) Ejecuci\u00f3n de procedimientos almacenados - Llamadas a procedimientos con CallableStatement - Par\u00e1metros de entrada y salida Contenidos 1- Introducci\u00f3n a las bases de datos relacionales \u00bfQu\u00e9 es una BDR? Estructura: tablas, claves primarias y for\u00e1neas Lenguaje SQL Casos de uso reales \u00bfQu\u00e9 es un conector (driver)? Tipos de gestores: embebidos vs. independientes Requisitos para establecer una conexi\u00f3n \ud83d\udccc Criterios: a), b), c), d) 2- Herramientas y conectores C\u00f3mo a\u00f1adir conectores Ejemplos: PostgreSQL, SQLite Primer programa que establece conexi\u00f3n \ud83d\udccc Criterios: c), d) 3- Operaciones sobre la BD Inserci\u00f3n (INSERT) Actualizaci\u00f3n (UPDATE) Borrado (DELETE) Consultas con SELECT Sentencias preparadas (PreparedStatement) Ejemplos: PostgreSQL, SQLite \ud83d\udccc Criterios: f), g), h), i) 4- Transacciones y control de errores \u00bfQu\u00e9 es una transacci\u00f3n? commit, rollback Manejo de excepciones \ud83d\udccc Criterios: j) 5- Procedimientos y Funciones \u00bfQu\u00e9 son y cu\u00e1ndo se usan? Sintaxis b\u00e1sica en PostgreSQL Acceso desde c\u00f3digo con CallableStatement \ud83d\udccc Criterios: k)","title":"\ud83d\udd39RA y CE"},{"location":"RA_CE/#ra-2-desarrolla-aplicaciones-que-gestionan-informacion-almacenada-en-bases-de-datos-relacionales-identificando-y-utilizando-mecanismos-de-conexion","text":"Criterio de Evaluaci\u00f3n Contenido Relacionado a) Ventajas e inconvenientes de utilizar conectores - Conectores JDBC - Bibliotecas ORM (Hibernate, JPA) - Comparativa: rendimiento, facilidad, portabilidad b) Gestores de bases de datos embebidos e independientes - SQLite (embebido) - PostgreSQL, MySQL (independientes) - Casos de uso y configuraci\u00f3n c) Uso del conector id\u00f3neo en la aplicaci\u00f3n - Selecci\u00f3n de driver JDBC adecuado - Configuraci\u00f3n del archivo pom.xml o build.gradle d) Establecimiento de la conexi\u00f3n - Clases DriverManager , Connection - Manejo de excepciones SQL - Pruebas de conexi\u00f3n e) Definici\u00f3n de la estructura de la base de datos - Modelado l\u00f3gico y f\u00edsico - Esquemas y tablas - Tipos de datos y restricciones f) Aplicaciones que modifican el contenido de la base de datos - Operaciones CRUD: INSERT , UPDATE , DELETE - Preparaci\u00f3n de sentencias ( PreparedStatement ) g) Definici\u00f3n de objetos para almacenar resultados - Objetos DTO/POJO - ResultSet y mapeo de resultados a objetos Kotlin/Java h) Aplicaciones que efect\u00faan consultas - Consultas SELECT simples y complejas - Filtros, ordenaciones y uniones ( JOIN ) i) Eliminaci\u00f3n de objetos tras su uso - Cierre de conexiones, sentencias y resultados - Uso de try-with-resources o use {} en Kotlin j) Gesti\u00f3n de transacciones - Comandos commit , rollback - Control manual y autom\u00e1tico de transacciones k) Ejecuci\u00f3n de procedimientos almacenados - Llamadas a procedimientos con CallableStatement - Par\u00e1metros de entrada y salida Contenidos 1- Introducci\u00f3n a las bases de datos relacionales \u00bfQu\u00e9 es una BDR? Estructura: tablas, claves primarias y for\u00e1neas Lenguaje SQL Casos de uso reales \u00bfQu\u00e9 es un conector (driver)? Tipos de gestores: embebidos vs. independientes Requisitos para establecer una conexi\u00f3n \ud83d\udccc Criterios: a), b), c), d) 2- Herramientas y conectores C\u00f3mo a\u00f1adir conectores Ejemplos: PostgreSQL, SQLite Primer programa que establece conexi\u00f3n \ud83d\udccc Criterios: c), d) 3- Operaciones sobre la BD Inserci\u00f3n (INSERT) Actualizaci\u00f3n (UPDATE) Borrado (DELETE) Consultas con SELECT Sentencias preparadas (PreparedStatement) Ejemplos: PostgreSQL, SQLite \ud83d\udccc Criterios: f), g), h), i) 4- Transacciones y control de errores \u00bfQu\u00e9 es una transacci\u00f3n? commit, rollback Manejo de excepciones \ud83d\udccc Criterios: j) 5- Procedimientos y Funciones \u00bfQu\u00e9 son y cu\u00e1ndo se usan? Sintaxis b\u00e1sica en PostgreSQL Acceso desde c\u00f3digo con CallableStatement \ud83d\udccc Criterios: k)","title":"RA 2 \u2013 Desarrolla aplicaciones que gestionan informaci\u00f3n almacenada en bases de datos relacionales identificando y utilizando mecanismos de conexi\u00f3n."},{"location":"Transacciones/","text":"Transacciones y Manejo de Excepciones \u00b6 La gesti\u00f3n de transacciones y el manejo de excepciones son dos aspectos fundamentales en el desarrollo de aplicaciones que interact\u00faan con bases de datos, ya que garantizan la integridad, la consistencia y la robustez de los sistemas. \ud83d\udd39Transacciones \u00b6 Una transacci\u00f3n es una secuencia de una o m\u00e1s operaciones sobre una base de datos que deben ejecutarse como una unidad indivisible. El objetivo es asegurar que todas las operaciones se completen con \u00e9xito o, en caso de fallo, ninguna de ellas se aplique, manteniendo as\u00ed la base de datos en un estado consistente. Por ejemplo, en una transferencia bancaria, si falla el abono en una cuenta, se cancela el d\u00e9bito en la otra. Las transacciones se gestionan mediante comandos como BEGIN TRANSACTION (para iniciar), COMMIT (para confirmar los cambios) y ROLLBACK (para deshacer los cambios en caso de error). Este mecanismo protege la base de datos frente a fallos parciales y situaciones de concurrencia, asegurando que los datos siempre reflejen una realidad v\u00e1lida y coherente. Propiedades de una transacci\u00f3n (ACID) Las transacciones garantizan propiedades fundamentales, conocidas por el acr\u00f3nimo ACID: Propiedad Significado breve Atomicidad Todas las operaciones se ejecutan o ninguna lo hace Consistencia El sistema pasa de un estado v\u00e1lido a otro Isolaci\u00f3n No interfiere con otras transacciones simult\u00e1neas Durabilidad Una vez confirmada, el cambio permanece Comandos clave Para controlar correctamente una transacci\u00f3n desde el c\u00f3digo, necesitamos usar tres comandos clave: commit() : Confirma los cambios realizados por la transacci\u00f3n, haci\u00e9ndolos permanentes. rollback() : Revierte todos los cambios realizados durante la transacci\u00f3n actual, volviendo al estado anterior. autoCommit Por defecto, muchas conexiones JDBC est\u00e1n en modo auto-commit , es decir, cada operaci\u00f3n se ejecuta y confirma autom\u00e1ticamente. Para usar transacciones de forma manual, debes desactivar este modo justo despu\u00e9s de abrir la conexi\u00f3n con la base de datos: val conexion = DriverManager.getConnection(\"jdbc:sqlite:miBD.sqlite\") conexion.autoCommit = false \ud83d\udd39Manejo de excepciones \u00b6 El manejo de excepciones en las transacciones es absolutamente necesario para garantizar que los datos de la base de datos no queden en un estado inconsistente o corrupto cuando ocurre un error durante una operaci\u00f3n. \ud83d\udc49 Cuando realizamos varias operaciones dentro de una misma transacci\u00f3n (por ejemplo, una transferencia bancaria), pueden ocurrir errores como: un fallo de conexi\u00f3n, un ID incorrecto, un valor nulo inesperado, un error l\u00f3gico como saldo insuficiente. \ud83d\udc49 Si no controlamos esos errores, la base de datos podr\u00eda: Aplicar solo algunas de las operaciones Dejar datos parcialmente modificados Generar resultados incorrectos para otros usuarios \ud83d\udc49 Para evitarlo se utiliza un bloque try-catch que: Llama a commit() si todo sale bien Llama a rollback() si ocurre cualquier excepci\u00f3n try { conexion.autoCommit = false // Varias operaciones SQL... conexion.commit() // Todo bien } catch (e: Exception) { conexion.rollback() // Algo fall\u00f3 \u2192 revertir println(\"Error en la transacci\u00f3n. Cambios anulados.\") } \ud83d\udccc \u201cUna transacci\u00f3n sin control de errores no es una transacci\u00f3n segura. Siempre hay que estar preparado para deshacer todo si algo sale mal.\u201d Ejemplo pr\u00e1ctico: transferencia entre cuentas Supongamos que quieres transferir 100 \u20ac del cliente A al cliente B. Debes: Restar 100 \u20ac de la cuenta de A. Sumar 100 \u20ac a la cuenta de B. Ambas operaciones deben realizarse juntas, o ninguna. val url = \"jdbc:postgresql://localhost:5432/banco\" val user = \"postgres\" val pass = \"admin\" DriverManager.getConnection(url, user, pass).use { conn -> try { conn.autoCommit = false // Iniciar transacci\u00f3n manual // Restar saldo a A val restar = conn.prepareStatement(\"UPDATE cuentas SET saldo = saldo - 100 WHERE id = ?\") restar.setInt(1, 1) // Cliente A restar.executeUpdate() // A\u00f1adir saldo a B val sumar = conn.prepareStatement(\"UPDATE cuentas SET saldo = saldo + 100 WHERE id = ?\") sumar.setInt(1, 2) // Cliente B sumar.executeUpdate() // Confirmar cambios conn.commit() println(\"Transferencia realizada con \u00e9xito.\") } catch (e: Exception) { conn.rollback() // Revertir si ocurre un error println(\"Error en la transferencia. Operaci\u00f3n anulada.\") e.printStackTrace() } } Ejemplo sobre la BD Tienda.sqlite La transacci\u00f3n har\u00e1 lo siguiente: Insertar una nueva factura: \"1001\" del clente 3. Insertar dos l\u00edneas de factura correspondientes a esa factura con los art\u00edculos \"B10000B\" y \"B10005B\" Actualizar el stock de los art\u00edculos implicados. Confirmar la transacci\u00f3n si todo va bien. Revertirla (rollback) si ocurre un error. Ejemplo_transaccion.kt import java.sql.DriverManager import java.sql.SQLException fun main() { val url = \"jdbc:sqlite:Factura.sqlite\" DriverManager.getConnection(url).use { conn -> conn.createStatement().execute(\"PRAGMA foreign_keys = ON;\") // Activa claves for\u00e1neas en SQLite try { conn.autoCommit = false // Inicia la transacci\u00f3n // 1. Insertar nueva factura val insertFactura = \"\"\" INSERT INTO factura (num_f, data, cod_cli, iva) VALUES (1001, '2025-07-31', 3, 21) \"\"\" conn.prepareStatement(insertFactura).executeUpdate() // 2. Insertar l\u00edneas de factura val insertLinea = \"\"\" INSERT INTO linia_fac (num_f, num_l, cod_a, quant, preu) VALUES (?, ?, ?, ?, ?) \"\"\" conn.prepareStatement(insertLinea).use { stmt -> stmt.setInt(1, 1001) stmt.setInt(2, 1) stmt.setString(3, \"B10000B\") stmt.setInt(4, 3) stmt.setDouble(5, 10.0) stmt.executeUpdate() stmt.setInt(1, 1001) stmt.setInt(2, 2) stmt.setString(3, \"B10005B\") stmt.setInt(4, 2) stmt.setDouble(5, 15.0) stmt.executeUpdate() } // 3. Actualizar stock de los art\u00edculos val updateStock = \"\"\" UPDATE article SET stock = stock - ? WHERE cod_a = ? \"\"\" conn.prepareStatement(updateStock).use { stmt -> stmt.setInt(1, 3) stmt.setString(2, \"A001\") stmt.executeUpdate() stmt.setInt(1, 2) stmt.setString(2, \"A002\") stmt.executeUpdate() } // 4. Confirmar transacci\u00f3n conn.commit() println(\"Transacci\u00f3n realizada con \u00e9xito.\") } catch (e: SQLException) { println(\"Error en la transacci\u00f3n: ${e.message}\") conn.rollback() println(\"Transacci\u00f3n revertida.\") } finally { conn.autoCommit = true } } } Nota Si se produjera alg\u00fan error durante la operaci\u00f3n \u2014por ejemplo, si no existiera el cliente o alguno de los art\u00edculos referenciados\u2014, la transacci\u00f3n se cancelar\u00eda por completo . Esto significa que no se insertar\u00eda la factura ni sus l\u00edneas, evitando as\u00ed la creaci\u00f3n de registros hu\u00e9rfanos. De este modo, la integridad referencial se mantiene intacta y la base de datos permanece en un estado consistente .","title":"\ud83d\udd39Transacciones y control de errores"},{"location":"Transacciones/#transacciones-y-manejo-de-excepciones","text":"La gesti\u00f3n de transacciones y el manejo de excepciones son dos aspectos fundamentales en el desarrollo de aplicaciones que interact\u00faan con bases de datos, ya que garantizan la integridad, la consistencia y la robustez de los sistemas.","title":"Transacciones y Manejo de Excepciones"},{"location":"Transacciones/#transacciones","text":"Una transacci\u00f3n es una secuencia de una o m\u00e1s operaciones sobre una base de datos que deben ejecutarse como una unidad indivisible. El objetivo es asegurar que todas las operaciones se completen con \u00e9xito o, en caso de fallo, ninguna de ellas se aplique, manteniendo as\u00ed la base de datos en un estado consistente. Por ejemplo, en una transferencia bancaria, si falla el abono en una cuenta, se cancela el d\u00e9bito en la otra. Las transacciones se gestionan mediante comandos como BEGIN TRANSACTION (para iniciar), COMMIT (para confirmar los cambios) y ROLLBACK (para deshacer los cambios en caso de error). Este mecanismo protege la base de datos frente a fallos parciales y situaciones de concurrencia, asegurando que los datos siempre reflejen una realidad v\u00e1lida y coherente. Propiedades de una transacci\u00f3n (ACID) Las transacciones garantizan propiedades fundamentales, conocidas por el acr\u00f3nimo ACID: Propiedad Significado breve Atomicidad Todas las operaciones se ejecutan o ninguna lo hace Consistencia El sistema pasa de un estado v\u00e1lido a otro Isolaci\u00f3n No interfiere con otras transacciones simult\u00e1neas Durabilidad Una vez confirmada, el cambio permanece Comandos clave Para controlar correctamente una transacci\u00f3n desde el c\u00f3digo, necesitamos usar tres comandos clave: commit() : Confirma los cambios realizados por la transacci\u00f3n, haci\u00e9ndolos permanentes. rollback() : Revierte todos los cambios realizados durante la transacci\u00f3n actual, volviendo al estado anterior. autoCommit Por defecto, muchas conexiones JDBC est\u00e1n en modo auto-commit , es decir, cada operaci\u00f3n se ejecuta y confirma autom\u00e1ticamente. Para usar transacciones de forma manual, debes desactivar este modo justo despu\u00e9s de abrir la conexi\u00f3n con la base de datos: val conexion = DriverManager.getConnection(\"jdbc:sqlite:miBD.sqlite\") conexion.autoCommit = false","title":"\ud83d\udd39Transacciones"},{"location":"Transacciones/#manejo-de-excepciones","text":"El manejo de excepciones en las transacciones es absolutamente necesario para garantizar que los datos de la base de datos no queden en un estado inconsistente o corrupto cuando ocurre un error durante una operaci\u00f3n. \ud83d\udc49 Cuando realizamos varias operaciones dentro de una misma transacci\u00f3n (por ejemplo, una transferencia bancaria), pueden ocurrir errores como: un fallo de conexi\u00f3n, un ID incorrecto, un valor nulo inesperado, un error l\u00f3gico como saldo insuficiente. \ud83d\udc49 Si no controlamos esos errores, la base de datos podr\u00eda: Aplicar solo algunas de las operaciones Dejar datos parcialmente modificados Generar resultados incorrectos para otros usuarios \ud83d\udc49 Para evitarlo se utiliza un bloque try-catch que: Llama a commit() si todo sale bien Llama a rollback() si ocurre cualquier excepci\u00f3n try { conexion.autoCommit = false // Varias operaciones SQL... conexion.commit() // Todo bien } catch (e: Exception) { conexion.rollback() // Algo fall\u00f3 \u2192 revertir println(\"Error en la transacci\u00f3n. Cambios anulados.\") } \ud83d\udccc \u201cUna transacci\u00f3n sin control de errores no es una transacci\u00f3n segura. Siempre hay que estar preparado para deshacer todo si algo sale mal.\u201d Ejemplo pr\u00e1ctico: transferencia entre cuentas Supongamos que quieres transferir 100 \u20ac del cliente A al cliente B. Debes: Restar 100 \u20ac de la cuenta de A. Sumar 100 \u20ac a la cuenta de B. Ambas operaciones deben realizarse juntas, o ninguna. val url = \"jdbc:postgresql://localhost:5432/banco\" val user = \"postgres\" val pass = \"admin\" DriverManager.getConnection(url, user, pass).use { conn -> try { conn.autoCommit = false // Iniciar transacci\u00f3n manual // Restar saldo a A val restar = conn.prepareStatement(\"UPDATE cuentas SET saldo = saldo - 100 WHERE id = ?\") restar.setInt(1, 1) // Cliente A restar.executeUpdate() // A\u00f1adir saldo a B val sumar = conn.prepareStatement(\"UPDATE cuentas SET saldo = saldo + 100 WHERE id = ?\") sumar.setInt(1, 2) // Cliente B sumar.executeUpdate() // Confirmar cambios conn.commit() println(\"Transferencia realizada con \u00e9xito.\") } catch (e: Exception) { conn.rollback() // Revertir si ocurre un error println(\"Error en la transferencia. Operaci\u00f3n anulada.\") e.printStackTrace() } } Ejemplo sobre la BD Tienda.sqlite La transacci\u00f3n har\u00e1 lo siguiente: Insertar una nueva factura: \"1001\" del clente 3. Insertar dos l\u00edneas de factura correspondientes a esa factura con los art\u00edculos \"B10000B\" y \"B10005B\" Actualizar el stock de los art\u00edculos implicados. Confirmar la transacci\u00f3n si todo va bien. Revertirla (rollback) si ocurre un error. Ejemplo_transaccion.kt import java.sql.DriverManager import java.sql.SQLException fun main() { val url = \"jdbc:sqlite:Factura.sqlite\" DriverManager.getConnection(url).use { conn -> conn.createStatement().execute(\"PRAGMA foreign_keys = ON;\") // Activa claves for\u00e1neas en SQLite try { conn.autoCommit = false // Inicia la transacci\u00f3n // 1. Insertar nueva factura val insertFactura = \"\"\" INSERT INTO factura (num_f, data, cod_cli, iva) VALUES (1001, '2025-07-31', 3, 21) \"\"\" conn.prepareStatement(insertFactura).executeUpdate() // 2. Insertar l\u00edneas de factura val insertLinea = \"\"\" INSERT INTO linia_fac (num_f, num_l, cod_a, quant, preu) VALUES (?, ?, ?, ?, ?) \"\"\" conn.prepareStatement(insertLinea).use { stmt -> stmt.setInt(1, 1001) stmt.setInt(2, 1) stmt.setString(3, \"B10000B\") stmt.setInt(4, 3) stmt.setDouble(5, 10.0) stmt.executeUpdate() stmt.setInt(1, 1001) stmt.setInt(2, 2) stmt.setString(3, \"B10005B\") stmt.setInt(4, 2) stmt.setDouble(5, 15.0) stmt.executeUpdate() } // 3. Actualizar stock de los art\u00edculos val updateStock = \"\"\" UPDATE article SET stock = stock - ? WHERE cod_a = ? \"\"\" conn.prepareStatement(updateStock).use { stmt -> stmt.setInt(1, 3) stmt.setString(2, \"A001\") stmt.executeUpdate() stmt.setInt(1, 2) stmt.setString(2, \"A002\") stmt.executeUpdate() } // 4. Confirmar transacci\u00f3n conn.commit() println(\"Transacci\u00f3n realizada con \u00e9xito.\") } catch (e: SQLException) { println(\"Error en la transacci\u00f3n: ${e.message}\") conn.rollback() println(\"Transacci\u00f3n revertida.\") } finally { conn.autoCommit = true } } } Nota Si se produjera alg\u00fan error durante la operaci\u00f3n \u2014por ejemplo, si no existiera el cliente o alguno de los art\u00edculos referenciados\u2014, la transacci\u00f3n se cancelar\u00eda por completo . Esto significa que no se insertar\u00eda la factura ni sus l\u00edneas, evitando as\u00ed la creaci\u00f3n de registros hu\u00e9rfanos. De este modo, la integridad referencial se mantiene intacta y la base de datos permanece en un estado consistente .","title":"\ud83d\udd39Manejo de excepciones"}]}